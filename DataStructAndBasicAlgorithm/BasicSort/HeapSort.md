# 大根堆 2020/3/31 学习记录  
## 创建大根堆
**1.创建大根堆**  
大根堆可以看成一个完全二叉树，每个非叶子节点均大于其左右子节点。此外完全二叉树满足一些性质，比如索引号为n的非叶子节点的左子节点为2*n,右子节点若存在为
2*n+1;根据此特性我们可以直接用一个一维数组来模拟堆的创建过程。  
```
public static void BuildHeap(int []arr,int leafcount)
    {
        for(int i=leafcount;i>=0;i--){
            AadjustDown(arr,i,arr.length-1);//注意点1
        }
    }

    public static void AadjustDown(int arr[],int leafIndex,int len)
    {
        arr[0]=arr[leafIndex];
        for(int innerIndex=2*leafIndex;innerIndex<=len;innerIndex*=2)
        {
            if(innerIndex<len&&arr[innerIndex]<arr[innerIndex+1])//注意点2
                innerIndex++;
            if(arr[innerIndex]<arr[0]) {break;}//注意点3
            else {//注意点4
                arr[leafIndex] = arr[innerIndex];
                leafIndex = innerIndex;

                  }
        arr[leafIndex]=arr[0];//注意点5
        }
    }
```  
**注意点1**  
如果把一维数组看成一个堆，此时还不一定满足大根堆或者小根堆的要求；因此我们需要对所有非叶子节点进行一个调整来满足大根堆的要求。  
**注意点2**  
这里为什么有一个循环呢，首先比如我们对根节点进行处理，就是在根节点的子节点中找到一个比根节点还大的值，然后进行值的互换，好像一看是满足需要的啊。
我们一起想想这里会有一个什么问题，假如我们互换之后根节点的左节点的值，此时应该就是之前根节点的值，若这个节点还有子节点同时该节点的值不满足大根堆
的要求，我们是不是要继续调整，所以有一个循环。这里的判断条件是左右子节点都存在，然后同时左子节点小于右子节点，那么是不是对于之后的操作都在右子节点的子二叉树上面呢。所以索引加一为什么左边就没有加额外的数呢，这里大家可以思考一下。  
**注意点3**  
这里有可能是左子节点或者右子节点比它们的父节点大，所以如果子节点小于父节点已经满足大根堆的要求。则直接返回，不对左右子节点开头的子二叉树做处理。  
**注意点4**  
关键的一步，如果某个非叶子节点的子节点值比父节点大，那么我们将子节点的值赋值给此时的非叶子节点，然后更新非叶子节点的索引为其提供值的子节点的索引。
**注意点5**  
回写，我们在进行一个一些列的处理后，需要将此时非叶子节点的值写回到初始的非叶子节点。然后进行下一次循环判断。
## 大根堆的排序  
大根堆的排序则相对简单，从数组中最后一个元素开始分别于根节点交换，然后调用AadjustDown方法来做调整即可。  
