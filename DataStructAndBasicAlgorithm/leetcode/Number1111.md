# leetcode 1111.有效括号的嵌套深度解题思路  
这里不上题目了直接放一个连接[1111.有效括号嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/). 
用depth(A)表示A的嵌套深度，比如（（））的嵌套深度可以表示为【1,2,2,1】,也就是栈的深度;  
**疑惑解析点1**  
有效括号我的理解就是可以为空，不为空的时候逐一入栈出栈操作后，栈为空则为有效括号；  
**疑惑解析点2**  
有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，这里A和B的意思是比如有一个字符串"(())",这里为了好看描述为{'0(','1(','2)','3)'}索引和值，可以
分成A{'0(','3)'}和B{'1(','2)'}，但不可以是A{'0(','1(','3)'}和B{'1(','2)',')'}这里一定要好好理解不相交的含义。  
**疑惑解析点3**  
选出任意一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。说点题外话，在有效括号中，“（）“”必定是成对出现，比如有N个“（”，则一定有
N个“)”,并且成对出现的“（）”它们所处的栈深度一致，也就是说在“（）”中可能有很多“（）“”符号，但是随着入栈出栈“（”与“）”的深度会一致，可以自己手写一下体会这个
过程；此外对于“（”来说，与之配对的“）”有相同的奇偶性，无非中间多加几个2*n对吧。**重点来了**，如果我们想让max(depth(A), depth(B))的取值尽可能小，是不是
只要将A和B长度尽量一致就可以了呢，这里将奇数位的“（”赋值给A，偶数位的“（”赋值给B，仔细想想这句话，还是想不通可以参考下面这个例子，比如对于数字10，分解成A+B=10；我们求max（A，B）的最小值，是不是只要取
A=5，B=5就行了呢，上面也是这么一个道理。  

---
**编码解析**  
```java
class Solution {
    public int[] maxDepthAfterSplit(String seq) {
      int [] reuslt=new int[seq.length()];
      int d=0,count=0;
      for(int index=0;index<seq.length();index++){
          char c=seq.charAt(index);
          if(c=='('){
              d++;
              reuslt[count++]=(d%2);
          }
          if(c==')'){
              reuslt[count++]=(d%2);
              d--;
          }
      }
      return reuslt;
    }
}
```  
先用一个数组来保存N个字符的嵌套深度，但是在本例中只有“（”会入栈，所以用一个变量d来表示栈的的深度就可以了。  
之后循环遍历每一个字符，第一个字符肯定是偶数位（0开始，认为是偶数位）的“（”，因此深度为1，余2是为了满足该字符在A中则为0，不在则为1；如果理解了我上面
所说的，那基本上这段代码就很好理解了。因为是“（”且偶数位已经默认为在A字符串中了，则d为偶数余2为0,；但是“（”且奇数位说明在B中，对2求余为1。**注意**
遇到“）”的时候是先写入栈深度再减1，是因为我们的模拟栈的过程中只放了“（”，由于成对出现和题意的关系，这里的深度和成对的“（”的一致。
