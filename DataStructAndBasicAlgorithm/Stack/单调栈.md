# 学无止境 2020/5/30 学习记录  
**1.题外话**  
因为有时候有些题是直接将题解写到了力扣的官网上的，所以在github就没写，当然这段时间太懒了，距离上一次写已经过去了8天了。继续解读官方题解  
**2.题目**  
老规矩，废话少说，上题目给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
再贴一个官网的图片  
![矩阵面积](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)  
**3.解题**  
做过接雨水的同学，肯定马上就能想到解决办法（暴力法），按以下几个步骤来做：  
- 遍历每个`index`对应的柱子，以`heights[index]`作为所求矩阵面积的高  
- 从当前位置往左找到一个第一个高度比当前高度小的位置，标记为left,注意不要越界  
- 从当前位置往右找到一个第一个高度比当前高度小的位置，标记为right  
- 则当前`index`对应的最大面积为`(heights[right]-heights[left]-1)*heights[index]`  

可能之前没坐过接雨水的同学会有疑问，为什么可以这么做呢？这是因为如果当前位置对应的柱子高度是最小的，那么最大的面积一定是当前位置往两边延展到左右两个位置
对应的柱子高度都小于当前位置，这和木桶原理一样，如果还有疑问的同学可以跟着以上的步骤简单的动动笔就能得到结果。代码我就不贴出来了。  
**4.优化**  
当然，暴力法做完过后都要考虑有没有优化的余地，常见的方式有减少不必要的比较和`以空间换时间`为主，这道题我们选择的是以空间换时间的方式，这里引入了一个数据
结构新的使用方式，**单调栈，就是说里面的元素要么是从小到大，要么是从大到小。**，目前还看不出来这个结构有什么用，继续解读一下官方题解你就会发现它的magic之处
了，问题就变成了怎么用空间来换时间了呢？
- 我们回顾一下暴力解法是怎么做的，找到左右两边第一个小于的边界位置，可以先抛出一个结论
- 有两个位置`a`和`b`，其中`heights[a]>=heights[b]`，对于一个柱子`c`，其中`c>b>a`,则a一定不会是c左侧且最近的小于其高度的柱子,通俗的说就是c在向左找小于其
高度的柱子的时候，`b`比`a`小，如果是要比`c`小，那么首先肯定是`b`，`a`就被挡住了。
- 因此我们用一个栈来存储一个递增的index，并且这个递增`index`对应的`height`也是递增的。
- 用两个数组分别存储对应位置的左右边界（也是第一个小于当前位置高度的索引）
- 遍历元素，如果当前当前栈为空，也就是没有比当前柱子小的柱子，那么定义为`-1（哨兵）`，如果栈不为空，则一直出栈直达栈顶元素第一次小于当前柱子的高度，然后将对应的index存储到数组中，同时将当前位置push到栈中这个过程执行两次，正序和逆序,逆序的哨兵定位heights.len;
- 最后遍历对应位置的左右边界，`(right-left-1)*height`也就是答案了，然后迭代求最大就可以了。

**4.总结**  
关于优化部分我没讲清楚原理，但是过程说的比较清楚，这里单调栈的作用就是存放当前位置之前小于当前柱子的集合。由于`stack`是递增的，比较的时候只要找到当前位置第一次小于当前柱子的位置就可以了，平均来说少了很多比较，大大提升了效率。
