# 截止 2020/4/22 树的学习记录  
**必备知识**  
一般而言，树的操作一般都与深度优先搜索（DFS）和广度优先搜索（BFS）有关，当然我目前做的都是简单的树操作题，一般的深度搜索和广度搜索就能办到，深度搜索
一般辅助空间用栈，广度搜索用队列。具体来说的实现方式可以通过递归来实现深度优先，递归需要注意返回条件，还有有返回值的递归有时候能帮我们省了很多事，迭代
实现广度优先。  
**老规矩，分析题开始**  
当然题目来源都是力扣哈，我是在力扣上刷题的。先看一道简单的热热身，**如何求一个BST二叉树给定两个节点（这两个节点一定在这个树上）的最近公共祖先**。今天不去让我惊讶系列了；我们一起来看看问题，先分析一下：  
1.这两个节点的位置有两种可能  
 -  其中节点是另一个节点的父节点，当然这种情况可能发生在某个节点的左子树，也可能右子树上。
 -  任意一个节点都不是另一个节点的父亲节点，那么最近的父节点只能在深度递减的某一层的某一个节点上了。 
 ---
2.进一步分析，我们这里是一个BST，一定要注意到，还有我一直强调的一件事就是我们要知道我们在做一件什么样的事，不管怎么做，我们先定一个function为A表示为找出给得两个节点的父节点，好了，接下来的内容就是怎么填充函数的内容了，首先我们这里是一颗二叉搜索树，既然是找东西，那肯定少不了比较是吧。好吧，怎么比呢，
我们想一下这里又有哪些情况  
 - 要查找的两个节点值都比当前当前节点的值大，那么是不是意味着当前节点肯定不是这两个的**最近父节点**了，既然比当前节点值还大，那么只有去当前节点的右子树
 寻找父节点了。
 - 同理，比当前节点的值都小，只有去左子树找父节点了。
 - 最有意思的就是第三种，如果这两个节点既不满足同时比当前节点大或者小，**那么意味着什么呢，是不是我们的答案就出来了呢**，那么当前节点就是两个节点的最近父节点啊，大家好好想想，理解一下这句话，两个节点，其中一个节点比当前节点小，另一个节点比当前节点大，这又是一个BST，那么是不是当前节点就是我们要找的节点呢。可能有些同学还是没反应过来，这两个节点**不一定在同一层**，就算不在同一层，在当前节点的右边所有节点都比当前节点大啊，左边都小。是不是就知道了。  
---  
3.拨开迷雾的时候到了  
有了2中的进一步分析，那么废话少说，给各位大爷献上代码。
```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
       if(p.val<root.val&&q.val<root.val)return lowestCommonAncestor(root.left,p,q);
       if(p.val>root.val&&q.val>root.val)return lowestCommonAncestor(root.right,p,q);
       return root;
    }

}
```
没错短短数行就达到了要求。  
4.**进阶**  
如果上面的讲解中，不是BST怎么办，就是一个普通的二叉树呢，那该怎么做呢，老规矩，分析分析分析，三思而后行。我们还是先来分析一下，不过就不从头分析了，
直接在上代码，在代码中逐一分析。  
```
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      //边界条件，什么时候函数返回呢，就是节点为空，或者我们找到其中的某一个节点了
       if(root==null||root==p||root==q)
       {
           return root;
       }
       //在当前节点的左右子树上去查找这两个节点是否在其子树上
       TreeNode left=lowestCommonAncestor(root.left,p,q);
       TreeNode right=lowestCommonAncestor(root.right,p,q);
       //重点，如果left为空，则说明要找的节点肯定在当前节点的右子树上，递归是把左子树都搜索完了的
       if(left==null)
       {
           return right;
       }
       //同理
       if(right==null)
       {
           return left;
       }
        //最后，如果left和right都不为空呢，意味着什么啊，当前节点就是他们的最近父节点，因为就算没有BST的大小关系，这
        //里既然返回了节点就说明这个节点在当前节点的某一个位置，那么自然当前节点就是他们的父节点，有些同学可能会问，
        //万一这个节点不是最近的节点怎么办，不会出现这种情况哈,好好想一想，这么问一般而言没理解到递归的精髓，递归这
        //里是深度优先，是到底了才会返回，从下面往最顶上找，只要找到了第一个那自然是最近的，层层传递回去，自然是最近的。
        return root;
    }
```  
最后上个图，大家如果没理解我说的话，跟着图中的节点走一遍，没办法，这就是一种思维能力，你想过了想清楚了才会觉得就是那么回事，没想过
就会有无从下手的感觉。![二叉树](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png)
