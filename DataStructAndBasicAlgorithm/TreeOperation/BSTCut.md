# BST的修剪  
**1.题目**  
给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。
来源：力扣（LeetCode）。  
**2.分析**  
一开始看到这个题目很敏锐的意思到其实有三种情况。  
- CurrNode.val<L 就是说当前节点比最小范围都要小，那么我们目标的树肯定在右子树上  
- CurrNode.val>R 就是说当前节点比最大范围都要大，那么我们目标的树肯定在左子树上  
- CurrNode.val>=L&&CurrNode.val<=R 正常情况，对于左右子树都要进行递归  
边界条件就是为空嘛，但是就算情况分析清楚后还是感觉没有理清题目。直接看的官方代码  
```
 /*
    完全抄袭需要好好想想，一时难以理解。
    **我们的函数的功能就是对当前的root节点进行一个范围在【L,R】内进行修剪，然后返回修剪后的结果**
    */
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if (root == null) return root;
        //重点理解下面两个return ，注意看此时并没有将进行子树的修改，为什么呢，因为此时节点
        //的值要么比最大值大了要么比最小值小了，当前节点的子树也许还有存在符合要求的值
        //所以继续递归调用剪枝函数直到找到一个符合要求的值或者没找到返回一个null呢。
        if (root.val > R) return trimBST(root.left, L, R);
        if (root.val < L) return trimBST(root.right, L, R);
        //下面是正常情况，如果当前节点刚好在L和R的范围内，那么只需要分别修改左右子树的连接即可，因为当前节点
        //的子树有可能存在上面特殊情况中的一个
        root.left = trimBST(root.left, L, R);
        root.right = trimBST(root.right, L, R);
        return root;
    }
```  
# 举三个特殊情况（针对根节点）  
**1.第一种,二叉树的数组为[7,6,null,4]**  
此时要求的范围的是[8-10],很明显，我们的最小值比当前的根节点都要大，所以按照要求直接去右子树中去找，递归后未找到满足范围的节点，所以修剪后直接返回null；如果找到了则进入第三种情况。  
**2.第二种,二叉树的数组为[7,null,8,null,null,null,9]**  
此时要求的范围的是[3-4],很明显，我们的最大值比当前的根节点都要小，所以按照要求直接去左子树中去找，递归后未找到满足范围的节点，所以修剪后直接返回null；如果找到了则进入第三种情况。  
**3.第三种,二叉树的数组为[2,3,4]**  
此时要求的范围是[1-5]，很明显，根节点在范围内，因此我们要特别注意，要修剪，怎么修剪呢，就是**改变当前节点符合要求的左右子树指针**。在第一种和第二种
的情况如果第一次递归A节点值在范围内，对他的左右子树进行递归，假如A节点只有左子树B，但是B节点的值不在范围内，那么我们只能对B节点的子节点CD进行递归了（当前节点值不满足范围，为何还要对当前节点的子树进行递归，因为我们这里是二叉搜索树，右子树的值比当前节点大，左子树的值比当前节点小，可能存在满足范围的值，所以要继续递归调用），
假设C节点为null，就是B没有左子树，那么B节点只有一个右子树D了，此时D是满足范围的，我们返回D节点给B节点，因为B节点的值不在范围内我们无需处理，因此B节点将返回的D再返回给了A，此时A.left=D.达到了剪枝的效果也就是把B这个不满足范围的节点给剪去了。大家一定要好好想想，多动手画一画，感受一下。
