# 2020/5/6 学习记录  
## 没错，我又一次被动态规划给虐了  
**1.题目**  
老规矩，还是先上题目，在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 
的整数，然后你有三种购票方式，一种呢是一天票，当天失效；另一种是周票；最后一种是月票；自然价格也是不同的，这里给的是[1,7,15]；然后让你求出这个旅行计划的
最低话费出来。  
**2.分析解题**  
没错，看到这个题，我首先就想到了贪心或者是动态规划，但是还是被虐的体无完肤，想了很久都没一个清晰的思路；还是对官方的方法一进行一个二次解读吧；在讲解之前有
**一个事情我们是要知道了，这个旅行日数组最长是什么情况呢，没错，就是[1,2,3,4,5,.....,364,365]，并且不会跨年**,也就是说每一天都是旅行日，当然这很不科学，也很极端，就算
是有钱人也经不起这么折腾，跑题了跑题了。**如果这个旅行日数组的长度小于了365是不是意味着某些天数我们是不需要买票的啊，对吧，我都不出去玩，我为什么要买票**，
好了，有了上面的两个疑惑解析后，进入正题，定义状态，这个没什么说的，dp[i]为从第i个旅行日到一年结束的最低花费(这里是从前往后算)。重点在状态转移方程上面。  
当第i个旅行日不出门的时候：  
$$dp[i]=dp[i+1]$$  
当第i个旅行日出门的时候：  
$$dp[i]=min(cost[j]+dp[i+j])    j={1,7,30}$$  
不出门倒好理解，因为我第i个旅行日不出门，那就不用买票，那么费用没有变化啊，那么自然和下一个旅行日的花费是一样的（**这里的旅行日之间不一定是相连的**），
第i个旅行日要出门该如何理解，首先要知道，对于j而言都是一段时间内有效，那么在这个时间内我就不用再次买票了，我所关心的是这个j结束后的dp[i+j]最低花费是多少
，又因为我们这里是从前往后算，所以dp[i+j]此时已经是知道了的。**换句话说，也就是从i这个旅行日到一年结束的最低花费就等于当前j的价格，加上从i+j到一年
结束最低花费的价格和**。  
其实讲到这里大概很多地方都讲清楚了，这里吧也有那么一点点贪心算法的味道在里面。但是如何编码呢，对吧，shom me code to 各位大佬，这也是很关键的一步。  
**3.代码解析**  
这里为什么要单独领出来解读一次，就是包括我们这种初级的同学，一般动态规划都是制表法制表法搞定了，然后通过数组或者滚动数组的概念节约空间。这里还有另一
技巧就是一般而言我们声明备忘录都是int，而默认的int数组都是0，我们的值也许就有0，所以不好处理，我们这里直接用integr类型的数组来处理就可以了。好的，废话不多
说了上代码，直接还是用一维数组不用官方的递归，代码如下：  
```
  static int[] cost;
    static Integer[] memo;
    static HashSet<Integer> day;
    public int mincostTickets(int[] days, int[] costs) {
        cost=costs;
        memo=new Integer[366];
        day=new HashSet<>();
        for(int d:days)
        {
            day.add(d);
        }
        for(int i=365;i>=1;i--)
        {
            if(day.contains(i))
            {
                //这里的三目用括号括起来，大家把365带进去体会一下就知道了
                memo[i]=Math.min(Math.min((i+1>365?0:memo[i+1])+cost[0],(i+7>365?0:memo[i+7])+cost[1]),(i+30>365?0:memo[i+30])+cost[2]);
            }
            else
            {
                memo[i]=i+1<=365?memo[i+1]:0;
            }
        }
        return memo[1];
    }
```  
这么做是没问题，时间呢，5ms，其实对于我来说差不多了，但是谁让我先看了官方的解答呢，把官方的递归来贴上来解读一遍吧。  
```
class Solution {
    int[] costs;
    Integer[] memo;
    Set<Integer> dayset;

    public int mincostTickets(int[] days, int[] costs) {
        this.costs = costs;
        memo = new Integer[366];
        dayset = new HashSet();
        for (int d: days) {
            dayset.add(d);
        }
        return dp(1);
    }

    public int dp(int i) {
        if (i > 365) {
            return 0;
        }
        if (memo[i] != null) {
            return memo[i];
        }
        if (dayset.contains(i)) {
            memo[i] = Math.min(Math.min(dp(i + 1) + costs[0], dp(i + 7) + costs[1]), dp(i + 30) + costs[2]);
        }
        else {
            memo[i] = dp(i + 1);
        }
        return memo[i];
    }
}
```  
用递归的好处呢，就是越界条件好处理，但是一定要注意最后那个return，想想除了memo中不存在外，为什么要return 一下。我这里举一个很简单的例子，就是如果
某个旅行日在经过+1，+7，+30后不在我们的旅行日数组中，那么他会一直递归调用找到第一个存在的memo，这也是为什么最后一句要return了。还有一个好处就是省时间，避免了很多无所谓的判断，比如我从1-365都要用contains一遍，这里不用，所以时间上会2倍多。

