# 2020/5/3 学习记录  
**1.题目**  
题目很简单，就是求一个数组中连续的子数组之和最大的那个子数组。这个题本该是一个月前做过的，但是显然当时做的太快，没有好好总结，就忘了。老规矩了，开始思考
，这个题如果只是考虑达到要求可以直接两遍循环，用一个临时变量保存当前的最大值，这样也可以达到要求，这么写的代码很简单，我这里就不写了；问题就在于这么做
O（n^2）的时间复杂度对于数据量大的情况下比如10w，或者8w等等可能大概率会超出时间限制。  
**2.优化方案1--DP**  
其实，DP真的没有什么好讲的，都是触类旁通，只有多做了就会有感觉；一般而言就是看问题是否能用DP解决，如果能先定义状态方程，再定义状态转移方程，最后求解即可。
但是实际上DP确实还是蛮复杂的。先问一个额外的问题，**我们题目给出的数组是怎么组成的？，是否有点莫名其妙，其实就是问这些数组里是否是正数和负数混合组成的**，
也就是说这个数组肯定有至少一个负数，不然还求什么最大和的子数组呢，**如果都是正数，最大和子数组就是数组本身了**。  
我们这里给出一个数组 **[-2,1,-3,4,-1,2,1,-5,4]**，按DP的一般思路都是令前I个怎么怎么样，这里定义状态真的是积硅步以致千里，我们定义dp[i]为以第i个数结尾
的连续子数组中和最大的那个值。什么意思呢？就是比如[-2,1,3],以第三个数也就是3结尾的子数组有两[-2,1,3]和[1,3]我们取和最大的那个也就是[1,3]。  
好，第二个问题状态转移方程。我们来思考这样的一个问题，比如现在求到了第i个数，那我们的dp[i-1]肯定是知道了，也就是第i-1个数中最大的那个子数组的和我们知道了
那我们的i该怎么处理呢，与i-1有什么关系呢，是不是就是如果dp[i-1]大于0了，那么我们就加上dp[i-1]，如下：  
$$dp[i]=dp[i-1]+num[i]$$  
如果dp[i-1]小于0，如下：  
$$dp[i]=num[i]$$  
其实这道理DP的精髓就在小于这里，大于0我们都知道了，以第i-1个数为结尾的最大子数组和为正说明有增益，我们可以直接加上当前的num[i]，**这里就相当于连续了**
好好想一下，因为如果小于0，那么都是负增益，我们可以直接舍去，因为负数加一个数b结果都是小于b的，仔细看小于0的dp[i]直接等于当前num[i]，这什么意思呢，就是
说从num[i]自己成为了一段子数组，i-1前面可能有多个，但是num[i]自己成为了一个子数组。如果num[i]为负数，那么下一个num[i+1]就同理舍弃num[i]，如果是正数
就加上num[i]，这里也就是连续的意思。最后的结果是数组中有num.len个值，这些值都是以当前数组为结尾的**连续**子数组中最大的那个数组和。因为我们再遍历一次
就能得到最大的连续子数组和，这里你也可以用一个变量保存当前的最大值，类似滚动数组的思想。
