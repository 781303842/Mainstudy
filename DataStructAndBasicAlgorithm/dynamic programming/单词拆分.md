# 单词拆分 2020年6月25学习记录  
**1.吐槽一下自己**  
太lazy了，忙于期末考试，快一个月没写了，赶巧最近已经了解一门课，又刚好碰上一道让我觉得可以做一下记录的题，还是老规矩，直接上题目，**题目不复杂，就是给定一个字符串，然后一个字典表（不重复，可多次）
使用字典表的单词，问该字符串能不能被拆分为字典表中的一个或者多个单词**  
**2.按例分析**  
其实我一直觉得的一种解决方法就是，第一先看看有没有类似的题目或者解决方法，如果没有那就先用尝试用暴力法来解决，ok，那我接下来先说说我自己暴力法的思路（也许有错）：  
 - 我们首先将字典表里的单词放在hash里面，这是准备工作。
 - 对字符串每一个字符结尾的单词都做一个遍历，比如以`i`个位置结尾的字符串有两种情况，一种是在字典表，一种是不在，在的话我就用`i+1`作为一个新的字符串开始又来遍历，看看是否在字典表中；如果不在继续用
 `i+1`作为结尾的字符串是不是在字典表中。  
 - 上面的过程还有一个点需要注意，需要一个栈保存每一个能在字典中找到单词的结尾索引，什么意思？就是比如有一个字符串`applepenapple`,字典表`[apple,pen]`，然后数组保存的是`[4,6,10]`，为什么要
 保存这个呢，原因就是有些情况下，如果你前面已经遍历了一个apple，此时索引为`4`，以`4`结尾的字符串在字典中，但是你是继续以`4+1`作为结尾呢？还是以`4+1`作为一个新的单词开始？
 - 综上，如果在某一次的遍历中都能找到对应的字符串，那么说明可以返回true，不行返回false。  
 ---
**3.优化**  
上面的逻辑看起来不是很复杂，但是总感觉和某个算法很像？没错，就是动态规划，既然说到了动态规划，那么我们首先还是按照动态规划的流程来：  
- 定义状态，设`dp[i]`为第`i`个位置结尾的字符串能不能被拆分为字典的某个组合；一般`dp[i]=true`，我们就不用管具体怎么拆分,只要知道以`i`结尾的肯定能被拆分就对了。  
- 状态转移方程，我们先列出状态转移方程  
$$ dp[c]=dp[i]&&check(i+1,c) $$  
啥意思呢，就是说如果`dp[i]`此时假如为`true`，也就是说以c结尾的字符串，我只需要去判断`(i+1)-c`这个位置的字符串就可以了。
