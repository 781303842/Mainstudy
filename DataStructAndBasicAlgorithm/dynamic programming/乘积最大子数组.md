# 2020/5/18 学习记录  
**1.题目**  
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。  
输入: [2,3,-2,4]  
输出: 6  
解释: 子数组 [2,3] 有最大乘积 6。  
**2.解答**  
一般情况下不会特意去讲暴力法，这题暴力法也能做；但是我们这里要讲的是通过动态规划的方法来做。有了之前的求连续的最大子序和的思路，我们能不能把最大子序和的
状态转移方程改为乘的呢，我们先试一下,在此之前定义状态`dp[i]`为以第i个数结尾的连续子数组最大积，一定是以`i`这个数结尾的连续子数组。  
$$dp[i]=max(dp[i−1]*num[i],num[i])$$  
这么一看过去好像是这么回事，但是实际上呢？我们忽略了和最大子序和的区别，如果`num[i]`为负数，那么`dp[i-1]`无论正负，`num[i]`对`dp[i]`的影响都是负增益的，
那么在求和的时候我们可以通过比较是否为负数直接另起一个连续的子数组（最小的子数组就是本身的一个数），这样能达到我们的要求了；但是对于乘法呢，`num[i]`
和`dp[i-1]`都要区分正负了。讨论如下：  
- `dp[i-1]`为正数，`num[i]`为正数，那么以i结尾的最大连续子数组必然是max(dp[i-1]*num[i]，num[i])
- `dp[i-1]`为正数，`num[i]`为负数，那么以i结尾的最大连续子数组必然是max(dp[i-1]*num[i]，num[i])
- `dp[i-1]`为负数，`num[i]`为正数，那么以i结尾的最大连续子数组必然是max(dp[i-1]*num[i]，num[i])
- `dp[i-1]`为负数，`num[i]`为负数，那么以i结尾的最大连续子数组必然是max(dp[i-1]*num[i]，num[i])  
考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，
并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，
并且希望它尽可能地大。那么一个一维的dp显然是办不到的，那我们可以定义两个，一个是`dpMin[i]`和`dpMax[i]`，显然初试的状态为  

$$dpMin[0]==num[0]==dpMax[0]$$  
那么可以推断出：  

$$dpMax[i]=max(dpMin[i-1]*num[i],dpMax[i-1]*num[i],num[i])$$  

$$dpMin[i]=min(dpMax[i-1]*num[i],dpMin[i-1]*num[i],num[i])$$    

到此我们初步的一个解答就完成了。  
```
class Solution {
    public int maxProduct(int[] nums) {
        int len = nums.length;
        int [] dpMax=new int[len];
        int [] dpMin=new int[len];
        dpMax[0]=nums[0];
        dpMin[0]=nums[0];
        for(int i=1;i<len;++i){
            dpMax[i] = Math.max(dpMax[i - 1] * nums[i], Math.max(nums[i], dpMin[i - 1] * nums[i]));
            dpMin[i] = Math.min(dpMin[i - 1] * nums[i], Math.min(nums[i], dpMax[i - 1] * nums[i]));
        }
        Arrays.sort(dpMax);
        return dpMax[len-1];
    }
}
```
**3.优化**  
对于动态规划而言，如果当前状态只与前一个状态有关，那么我们可以只用两个变量来表示，代码这里就不贴出来了。  
**4.总结**  
对于连续的子数组用动态规划来解决的问题，那么定义状态**一定是以i结尾的连续子数组**，一定要清楚这点。
