# 动态规划入门 2020/3/27学习记录  
**1.初识动态规划**  
---
这三天为了学好动态规划，做了不少动态规划的入门题；先不说各种概念，先从一道《剑指offer》的剪绳子开始,题目如下:  
>问题描述：给你一根长度为n的绳子，请把绳子剪成m段(m和n都是整数，n>1并且m>1)， 每段绳子的长度记为k[0],k[1],...,k[m]. 请问k[0]k[1]...k[m]可能的
>**最大乘积**是多少？
---
> 解题思路：1-3均为特殊长度，又因为至少分为两段，因此各自对应的乘积最大值分别为0,1,2；我们取长度为7来剪，按照一般的思路，我是不是从长度为1开始考虑剪
这条绳子，既然如此那就开始剪绳子。  
> 1.我从左边剪1，此时分为了（1,6）这两条长度；按照这种思路是不是就是对6再来剪，就是（1,5）...重复几次过后是不是就变成了（1,1,1,1,1,1,1）7段1长的绳子  
> 2.那么问题来了，7个1相乘还是1，显然不是我们想要剪成的长度集合；我们对上述过程倒回去到4的时候，我们对4进行剪操作后就变成了（1,3）那么（1,3）的最大值我们就知道了，3又可以分为（1,2）这种情况，显然，还是3本身比较大，所以就不用再对3进行剪操作了，但是4不止（1，3）一种剪法啊，我还以为用（2,2）同理我们得到最大值还是4（2*2).  
> 3.再倒回一点倒回到5，那么5是不是有（1,4）（2,3）二种情况呢，我们通过上一步骤已经知道了2,3,4能减出来的最大值，因此这里我们只要分别算出各自的乘积，取最大值就是5能减出集合乘积的最大值。6是不是也一样呢，就是（1,5）（2,4）（3,3）;到这里基本已经有个初步的模型了。  
> 疑问的地方：比如像我一样基础差的同学还会有点疑惑，上面不都是剪成2段的嘛，但是8的最大乘积集合为（2,3,3）是三段啊；我们再慢慢想想上面的过程，来了一段8的绳子，我可以剪成（1,7）（2,6）（3,5）（4,4）；而（2,6）中的6又可以被拆分为（1,5）（2,4）（3,3）；我想讲到这里应该清楚了，这是一个递归，所以每一段绳子通过上面的操作后可能都会被分成多段;  
---
**1.答案**  
经过以上的分析我们是不是可以设dp[i]就是长度为i的绳子所能剪出n种集合中集合元素相乘最大的哪一种，有点绕，打个比方就是（1,3）（2,2）取（2,2）的意思；因此状态转移方程就是dp[i]=max(dp[c]*dp[i-c]) c=1,2,3...i/2;再分析初始条件，显然就是dp[1],dp[2]=1 ,dp[3]=2.因此我们就能开始编码阶段了  
```` 
public static int Cult(int len){
        if(len<=1) return 0;
        if(len==2) return 1;
        if(len==3) return 2;
        int [] dp=new int[len+1];
        /*下面的意思是在剪的过程中为3,2,1就不需要剪了，本身就是最大值*/
        dp[0]=0;
        dp[1]=1;
        dp[2]=2;
        dp[3]=3;
        for(int i=4;i<=len;i++)
        {
            int tempmax=0;
            for (int blank=1;blank<=i/2;blank++)
            {
                int temp=dp[blank]*dp[i-blank];
                if(temp>tempmax)
                {
                    tempmax=temp;
                }
            }
            dp[i]=tempmax;
        }
        return dp[len];
    }
````  
好，到这里基本上也算对这道剪绳子有了了解，那我们来看看动态规划的适用条件  
1.最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。

2.无后效性将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。

3.子问题的重叠性 动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

4.解题步骤我目前认为一般有状态的定义，写出状态转移方程，找出初始条件，找出最优解。
