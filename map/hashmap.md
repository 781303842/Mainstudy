# 2020.3.10 hashmap学习记录  

**hashmap的一些关键点**  
hashmap 采用的数据结构在jdk1.7的时候采用数组+链表的组合来实现，在jdk1.8中是数组+链表+红黑树来实现。另外在jdk1.7中，hashmap有几个地方需要关注一下  
**1 提高性能**  
hashmap默认数组长度为16，也就是2<<4,hashmap中分配或者查找的过程是用key的hash值与数组长度做求余运算，一般而言我们会用%来实现求余运算，也就是hash（key）%arr.length，但是查看源码的过程中发现，jdk1.7中是用&符号来实现的，先抛出一个结论，数组长度为2^n时候，hash（key）%arr.length与hash（key）&（arr.length-1）是一致，并且当数组长度是2的幂次的时候性能更佳，我们举两个例子就能看出差别了。引用一张别人画的图。
![alt 属性文本](https://github.com/781303842/Mainstudy/blob/master/hashmap.png)
看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行与运算，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，为什么呢，比如说0010和0011与后者与运算后，只会得到0010，因此0011不会被用到，其它同理，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。就算如此也没有完美的事情，就算上面这么做了过后也还是会出现hash值高位不同低位相同导致最后与运算的结果一样，所以还要对hash的值进行一次扰动计算，其实就是为了分布更均匀。  `在jdk1.8中hash方法已经改为(h = key.hashCode()) ^ (h >>> 16)还是为了减少碰撞，提高性能`。  
**2 方便定位**  
（下面的内容不考虑红黑树）hashmap扩容时是乘2，按照上面来说就是从数组长度2<<4变成了2<<5，扩容后需要重新将元素定位，公式不变还是key.hashcode & (array.length - 1)，因此2<<5-1就等于11111，比原来的1111多了一位，那么如果与运算的时候多的高位为0，那么元素的位置依然是原来的位置，如果为1那么元素新的位置就是原来的低4位组成的原index，多出来的高位1按规则为16，所以新的位置就等于`原来的索引+原来的数组长度`。  
**3 jdk1.7扩容死锁**  
特别提醒：对象绝大多数情况下都是分配在堆中的，因此若数组中的元素是对象类型，那么数组中实际存放的是对象的引用，这里我们可以粗矿把当前数组中的元素存放的是一个32的内存地址。在jdk1.7中如果hashmap按2倍扩容时可能发生死锁，我们来分析一下具体原因，关于扩容的具体代码我就不上传了。我们都知道jdk1.7中采用数据+链表的结构完成hashmap，假设我们现在正在扩容，思路简单，两层循环，设current_node是我们当前的正在循环的数组元素，也可以理解为头结点，然后我们计算出当前节点数据在新数组中的位置，然后用current_node.next=newarr[hash(key)&(newlength-1)],如果新数组的此位置没有节点，那么current_node.next=null，然后newarr[hash(key)&newlength-1]=current_node.我们再来看一遍这个过程，当老数组拿到当前元素在新数组中的位置的时候，首先当前元素根据自身引用找到堆中具体存放的对象，然后修改自己对象的next为之前对象的引用。如果新位置没有元素那么next=null。然后我们将当前节点（也是一个对象引用）赋值给新数组的新位置，那么这个位置所存放的之前对象的引用将被当前节点的引用所取代。`进入正题`，如果上述过程不是在单线程，而是在多线程的情况下，会发生什么呢，比如有两个线程都执行到了current_node节点，两个线程中的current_node是一样的，那么线程2先暂停，线程1先执行，执行完的结果可能也不尽人意，某个数组位置还是有链表，并且对应之前老数组中某个位置的的链表中的一部分且是逆序,这个时候线程2被唤醒，然后使当前位置链表中最后一个元素又指向了当前位置，形成了死循环。  
**4 补充**  
关于jdk1.8中为什么hashmap的链表长度大于等于8的时候会变成红黑树，网上有两种答案；第一，就是根据泊松分布，负载因为为0.75的时候，长度为8的概率大于百万分之一，因此用7作为界点，小于等于7用链表，大于等于8用红黑树；另一种，大概意思是说红黑树的平均查找长度为log（n），底数应该是2，然后真数为8的时候，平均查找长度为3，而链表就是（1+8）/2=4.所以当大于等于8就用红黑树，小于的时候呢，红黑树为了保持平衡或者其它操作性能不一定会比链表好。
