# 什么时候适合建索引？  
值不易变动，并且值域大，重复数少。如果对于某个字段查出来特别多的值，那么就不适合建索引，可以通过explain查看执行计划。
# 索引  
1.B+树索引，也就是我们常用的索引，B+索引（多路平衡二叉树）  
- 聚集索引：按照主键（没有指定主键的话，如果有唯一非空列就是主键，都没有默认建立一个6字节的主键）构建一颗B+树，并且叶子节点存放所有的行记录。
    + 这颗B+树的根节点常驻内存，其它节点放在辅助中。可以认为每一个页（16k）包含多个主键，其中根节点对应的页常驻内存。
    + 我的观点和innodb技术内幕一样，聚集索引在物理上不连续，只是逻辑上的连续【非叶子节点对应页中的每一记录的索引都记录了一个偏移量】。（这里的连续指的是记录行在内存中地址是连续分配）。
- 辅助索引（非聚集索引）：非主键字段构造的一颗B+树（可以是复合索引，也可以是多个单字段索引），但是叶子节点不存放数据，只是存放主键和实际数据的地址。
    + 辅助索引的物理不连续，逻辑是连续的。因为叶子节点存放的是实际数据的地址。
- 辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。覆盖索引不用回表，就是查询字段都是索引的情况下。但要满足最左匹配，不能断，必须连续  

2.哈希索引，innodb引擎会根据表的使用情况来判断是否生成哈希索引。  
- 就是通过hash函数映射到一个地址，然后如果冲突了就通过拉链法（不止一种，比如再hash也可以）解决冲突，就是冲突后的位置形成一条链，就是数组+链表的形式可以认为。  

3.innodb是面向行的，每一个页中可以放多个行。页是innodb磁盘管理的最小单位，且不更改。

# 为什么用B+树来构建索引？  
- 一般如果我们要找一个目标值，通常做法就是对所有数据进行一个遍历，这样虽然能达到效果，但是如果数据量特别大，时间复杂度线性增加。
- 基于上面的数据是无序的，那么如果有序呢，对，就是二分查找，二分查找的理想的时间复杂度就是树的高度，到了log级别。二分查找可以对应二叉搜索树
- 如果用了二叉搜索树也会有问题，就是如果数据比较极端，比如单调递增或者递减，那么这个二叉搜索树的时间复杂度退化为线性了，我们要找到一个方法，或者一种结构。
- avl树或者平衡二叉树，由于二叉搜索树可能退化为n的时间复杂度，所以出现了平衡二叉树，任意两棵子树的高度不会超过1，这样就保证了查询不会出现特别极端的情况。  
- 上面都是针对数据结构本身而言，虽然avl树能达到我们的要求，但是mysql对于数据的管理都是以16k的页为单位，如果每一页都只存放一行记录，那么空间使用率太低了。因此出现了B树（多路平衡树，不止两个叉），这样
每个页空间中存放的行记录就变多了，在B树中，叶子节点和非叶子节点都会存放数据。（在B树，B+树中节点（一页）存放都不止一个主键或者记录）
- 虽然B树已经很好了，但是有一点要注意，在mysql中索引除了根节点常驻内存，其它的都会放在辅存中，意味着需要磁盘io将数据读或者写，B树的非叶子节点也会存储数据，磁盘io每次读取的数量是固定的，也就是意味着
次数更多的io，io通常比较耗费时间，所以出现了B+树，B+树除了叶子节点存放数据外，非叶子节点都只存放索引列，这样在空间利用率和时间消耗上取得了一个较为理想的点，另外，B+树的叶子节点都是有序的，并且叶子
节点之间通过双向链表关联，这样在查找区间数据的时候会比较快。
    + 说的直白点，B+树相对于B树，只在叶子节点存放数据，减少了io次数
    + 叶子节点之间通过双向链表关联，在查询区间数据上有优势。
    + B+树的高度一般在2-3层。
 - 为什么不能是红黑树？红黑树本质上来说还是一颗二叉树，不过是自平衡的二叉树，理论的删除查找的时间复杂度都是logn,二叉意味着每页存放数据较少，意味着树的高度更高，更多的磁盘io，所以在数据量大的情况好
 用B+树效果更好。  
 
 # mysql 每日一练  
 求每个类别下面前几的数据都可以用下面的方式（不包含并列）
 ```
 select emp_no,salary from salaries s1 where 
 -- 子查询表示的意思是在s1中的一行在同一个表中，id相同，大于我的个数，如果比我大的不超过3个，那我就是前三
(select count(1) from salaries s2 where s1.emp_no=s2.emp_no and s1.from_date>s2.from_date) <1  
order by emp_no desc
 ```
