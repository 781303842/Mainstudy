# 2020/3/16 jdk1.8下reentrantlock学习记录  
**1.基本组成** 
reentrantlock使用CAS+AQS实现的，AQS就是AbstractQueuedSynchronizer，是一个双向的的队列；CAS就是CompareAndSet。因此当有线程来访问的时候通过CAS改变state
的值尝试获取锁，如果成功则获取锁成功；如果失败则进入等待队列，这是如果是公平锁则从队列的头到尾依次尝试获取锁，新的线程也会被挂在队列尾部；如果是非公平锁，则
有可能被其它线程给获取了锁.  
**2. 特性**  
reentrantlock既是公平锁又是非公平锁、可重入锁、可中断锁，synchronize是非公平锁，不可中断锁、可重入锁；  
**3 重点流程**  
| 步骤 | 公平锁 | 非公平锁 |
| :----: | :----: | :---- |
| 尝试获取锁 | acquire(1) | 1.通过compareAndSetState方法尝试修改state的值为1（具有原子性），也就是一次只让一个线程通过 2.成功的话通过setExclusiveOwnerThread设置当前线程为独占线程。3.失败则调用acquire（1）方法 |
| 真正执行| 1.获取state的值，获取当前线程 2.如果state为0，再查询是否有比当前线程等待时间还长的线程，如果有再判断当前获得锁的线程是不是和当前线程是同一个线程 3.都不是的话返回false，获取锁失败 | 若上一步失败，则流程同左|
|  加入等待队列 | 1.将当前线程包装成一个node节点，通过addWaiter加入队列 2.将node传递给acquireQueued，如果满足则原来的head出队，如果失败判断是否能挂起 | 同左 |
| 解锁 | 1.调用tryRelease方法，如果请求解锁线程不等于当前专用线程则抛出异常 2.如果算上重人锁则最后一次state-1为0，然后设置当前专用线程为空 3.返回true| 同左 |
