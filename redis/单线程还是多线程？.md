# 单线程还是多线程？  
redis执行命令分3个阶段，接收命令，执行命令，回送结果。在执行命令阶段一直都是单线程（单线程说的是执行线程只有一个，还有其它辅助线程，比如RDB持久化产生的进程后产生的线程），如果说的详细一点在redis6.0及以前
具体分为：**套接字，io多路【多请求】复用【复用一个执行线程】，事件分发器，事件处理器**，如下图  
![redis执行过程](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/redis4.0.jpg)  

# 上面的问题  
关于io多路复用这里我就不做过多介绍了，可以看另一篇同步异步阻塞非阻塞的文章，在以前当io阻塞对象发现有可读事件时，将这些socket按序，放入队列，一次处理一个。那么问题也显然易见，redis在命令执行阶段是
单线程的，也就是说如果在处理当前socket时，write/read io会耽误大量的时间（cpu执行很快，主要是io耽误了，内存直接扩充，小心numa陷阱），我猜测用户数据发送到redis服务器后，是在redis服务器的内核buffer，要io系统调用，
发生用户态和核心态的切换，消耗时间。**因此，我们能不能把阻塞对象发现可读的socket拿出来通过一个线程池来执行命令的读取和解析，注意是读取和解析，并不是执行，执行还是要给单一线程来执行，这样在执行的
的过程中速度将会非常快，因为拿过来的就是执行命令，系统io调用已经交给辅助线程去做了，所以从这点上来说redis6.0可以认为是多线程了，但不是执行多线程，而是读取解析命令多线程**，这里还需要一个队列来放置辅助线程read的命令？
我觉得是性价比不是很高，因为cpu执行非常快，如果有必要，可以开辟一个符合当前系统的队列。  

# 结论  
redis执行线程一直都是单线程，为什么redis6.0号称多线程呢，是因为在执行socket read/write时是多个线程来做。
