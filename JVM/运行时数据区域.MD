# 运行时数据区域  
**定义** jvm把执行java程序的过程中会把它管理的内存区域分为若干区域，有些区域随着虚拟机启动就一直存在，有些随着用户线程的启动结束而建立和销毁。  

## 1.程序计数器（线程私有）  
程序代码执行前，会被编译成了一条一条的指令，而处理器同一时间只能执行一个线程中的指令，因此当前线程可能由于被分配的时间片结束而被挂起，为了更好的恢复，所以每一个线程都有一个自己的程序计数器区域，这是**私有**的。在java虚拟机中，字节码解释器就是通过改变程序计数器的值来获取下一条要执行的字节码执行。如果执行的是java方法，程序计算器记录的正在执行指令的地址，如果是native方法，则为undefine。  

## 2.java虚拟机栈（线程私有）  
官方定义说的是**java方法执行的线程内存模型，每执行一个方法，虚拟机会创建一种栈帧的数据结构，存放方法出口，操作数栈，局部变量等等**，通俗的理解就是把当前方法的出口也就是return的地方，形参，操作数等等放进一个栈的结构，栈帧在后面还会详细介绍。  

## 3.本地方法栈  
和虚拟机栈不同的只有一点，本地方法栈调用的nativate本地方法服务，而java虚拟机栈调用的是字节码服务。  

## 4.java堆（线程共享）  
此区域的主要目的就是存放几乎所有的对象实例，因为逃逸分析，栈上分配，标量替换等等优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。  
因为此区域也是GC工作的主要区域，按照大多数gc的工作原理，都会将堆分为新生代，老年代，永久代，eden区，from survive区，to survive区，无论咋分都只是为了更好的进行GC回收。  

## 5.方法区（线程共享）  
用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。包括运行时常量池，是动态的，程序在运行时也可以将常量放进常量池。  

## 6.直接内存去（额外，不属于运行时数据区域）  
在jdk1.4中引入的NIO，用nativate函数直接分配堆外内存，然后通过存储在堆中的某个对象作为这个内存的引用，这样能避免在某些场景下nativate和堆来回复制。不受堆大小限制，但是受本机总内存大小限制。



