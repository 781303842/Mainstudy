# 运行时数据区域  
**定义** jvm把执行java程序的过程中会把它管理的内存区域分为若干区域，有些区域随着虚拟机启动就一直存在，有些随着用户线程的启动结束而建立和销毁。  

## 1.程序计数器（线程私有）  
程序代码执行前，会被编译成了一条一条的指令，而处理器同一时间只能执行一个线程中的指令，因此当前线程可能由于被分配的时间片结束而被挂起，为了更好的恢复，所以每一个线程都有一个自己的程序计数器区域，这是**私有**的。在java虚拟机中，字节码解释器就是通过改变程序计数器的值来获取下一条要执行的字节码执行。如果执行的是java方法，程序计算器记录的正在执行指令的地址，如果是native方法，则为undefine。  

## 2.java虚拟机栈（线程私有）  
官方定义说的是**java方法执行的线程内存模型，每执行一个方法，虚拟机会创建一种栈帧的数据结构，存放方法出口，操作数栈，局部变量等等**，通俗的理解就是把当前方法的出口也就是return的地方，形参，操作数等等放进一个栈的结构，栈帧在后面还会详细介绍。  

## 3.本地方法栈  
和虚拟机栈不同的只有一点，本地方法栈调用的nativate本地方法服务，而java虚拟机栈调用的是字节码服务。  

## 4.java堆（线程共享）  
此区域的主要目的就是存放几乎所有的对象实例，因为逃逸分析，栈上分配，标量替换[对象逃逸](#allocation_object_optimize)等等优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。  
因为此区域也是GC工作的主要区域，按照大多数gc的工作原理，都会将堆分为新生代，老年代，永久代，eden区，from survive区，to survive区，无论咋分都只是为了更好的进行GC回收。  

## 5.方法区（线程共享）  
用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。包括运行时常量池，是动态的，程序在运行时也可以将常量放进常量池。  

## 6.直接内存去（额外，不属于运行时数据区域）  
在jdk1.4中引入的NIO，用nativate函数直接分配堆外内存，然后通过存储在堆中的某个对象作为这个内存的引用，这样能避免在某些场景下nativate和堆来回复制。不受堆大小限制，但是受本机总内存大小限制。  


# 以Hotspot虚拟机为对象解密  
## 1.对象的创建  
当java虚拟机遇到一个new指令时，会大致执行以下的步骤：  
- 去常量池中查找是否有当前类的符号引用。
- 检查这个符号引用代表的类是否已经加载，解析，初始化。如果没有那还要去执行相应的类加载过程。
- 类加载检查通过后，则在堆中新建一个大小确定的对象；这个分配的过程一般有两种方式
    - 带压缩的Serial、ParNew，可以使用“指针碰撞”，说白了就是从当前位置分配一段连续的空间。
    - 不带压缩的cms，必须用一个列表来记录那些空间可以分配对象，即空间的起点，长度等等信息。  
    
除了上面以外，对象的创建还要考虑一个问题，就是对象创建时候的安全问题，比如一个场景，A线程使用了正在分配空间，指针还没来得及修改，B线程使用了原来的指针进行空间的分配就会出问题。有两个解决方案：
- 通过CAS操作，即保证原子性，只有指针和预期的指针相等时才分配，不等失败
- 在堆中为每个线程分配一小块区域thread local allocation buffer，只有TLAB用完了分配新的区域时才需要锁定。  

之后才创建对象，除对象头之外都赋予0值，对象头中包含一些当前对象属于哪类，包含的元数据，哈希码，分代年龄，偏向锁，锁标志等等信息。对象包含三部分，对象头（mark work），对象数据，对齐填充。  

## 2.对象的访问方式  
- 通过句柄，优点：在堆中有一个句柄池，存放着reference的引用，该地址本身不易变动，即时是实际执行对象数据实例的指针因为GC原因发生变动，句柄本身的地址不会变，稳定；缺点：多了一次定位过程。  
- 通过指针，优点：通过指针直接访问。缺点：易变动。  

# allocation_object_optimize
## 1.对象逃逸  
三种状态：
- 全局逃逸：
    - 对象作为方法的返回值
    - 类的静态对象字段
- 参数逃逸：
    - 对象作为参数，方法之外无法访问
- 无逃逸：带来的一些便利（理想化）
    - 栈上分配：如果确认一个局部对象不会发生逃逸，那么可以将对象直接在栈上分配，这样对象就会随着方法的执行结束而销毁，GC的压力就会小一些
    - 同步消除：如果确认一个局部对象不会发生逃逸，那么就不会被其它线程访问，就不会引起竞争，就可以消去耗时的同步操作
    - 标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候将可能不创建这个对象，而改为直接在栈上创建若干个成员变量。比如point类中有integer a和b，那么访问的时候不会创建point对象，直接使用integer a和b代替。 
    


