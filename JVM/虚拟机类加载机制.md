# 类文件结构  
1.关于类文件结构就简单说一下，一个class字节码文件前4个16进制的数称为魔数，CAFEBABE,接下来是次版本号主版本号等等信息。接下来就是常量的个数  
2.常量池：常量池中每一种都是一个集合，包括基本的数据类型等。  
3.接下来是一些类或者接口的访问标志。  
4.类索引，父类索引，接口索引集合：如何找到一个类呢，当前类中有一个index，这个作为在常量池中类表的位置，找到后又是一个index，这个对应的是一个byte的常量，也就是类的全限定名。  
5.字段表：用于声明类和接口中声明的字段。  
6.方法表：访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表等等，注意code是放在属性表code属性里面。 
7.属性表：Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。  
关于类文件结构就简单了解一下。  

# 虚拟机类加载机制  
5个阶段，这些阶段执行过程可能存在交集。加载-【验证，准备，解析】（连接）-初始化-使用-卸载。其中解析和初始化不一定是上面的流程，比如动态绑定，这里举个简单的例子，有一个父类，有一个方法A，子类
继承后也有一个方法A，那么在main方法中通过Parent p=new Son(),p.A(),来调用A方法，那么虚拟机只有执行的时候知道去调用那个方法，不像类方法哪样一开始就可以确定。  
1.关于加载，主要做了以下三件事：  
- 通过类加载器去获取一个二进制流的class字节码文件。可能是从本地获取，也有可能是从网络，数据库地方。
    - 这个过程应该和验证阶段同时进行，一边读取，一边进行验证，验证的范围有文件结构的比对，如果文件格式都不对，那么肯定就不是一个正确的字节码文件
    - 格式验证完后，再来检验字节码文件中的语言也就是我们写的代码符不符合java语言规范
    - 如果语言也符合后，那就来检查语义了，举个例子比如不能把一个业务对象赋值给一个整形数据。
    - 最后一步就是符号引用的检验，这一步其实是加载过程中解析阶段做的事情。符号引用可以理解为类名，或者方法名都可以看做符号引用。
- 将静态的字节码加载到动态的运行时数据结构中去。
- 在java.lang.class生成一个该类的类对象，这个类对象对应一个类文件。而只有new或者其它方式要获取该类的实例化对象时，大多数情况下才会在堆中分配该类的对象。  

那什么时候会去执行加载动作呢，没有说，但是初始化的活，比较好理解的就是比如new对象的时候，或者访问一个静态字段或者方法等等，或者父类没有初始化，因为都要这些动作完成了，才能执行当前的动作。但是也有些情况
是不会触发类的初始化动作的，比如：
- 在子类中引用父类的静态字段。
- 类数组
- 引用常量，常量在准备阶段都已经放入常量池了，不对应任何的类。

2.验证，验证阶段前面3个是比较好理解，比较繁琐的就是符号引用验证。

3.准备阶段，就是给字节码文件的类字段分配内存赋值一个初值。比如布尔类型就是false，int就是0等等，除非该字段是常量，否则都按这种方式，常量的值不会变，所以可以分配内存后就赋值。  

4.解析，直接引用就是一个内存地址，符号引用任何合法的字面量且可以没有歧义的访问到想要访问的内容就是认为是符号引用。符号引用还会在第一次解析后缓存起来，比如同一个方法的调用位置可能很多。可以简单
理解为，解析阶段就是把符号引用转为直接引用的过程。包含以下几种：
- 接口或者类  
- 方法或者字段  
- 调用一个常量  

5.初始化  
jvm会自动生成一个clinit操作，会自动收集类中所有赋值操作和静态语法块。但这个操作不是必须的，如果没有任何赋值操作或者静态语句块就没必要了。并且这个方法具有同步操作，不能多个线程同时执行。  

# 类加载器  
一个类只有在同一个加载器下比较才有意义，换句话说就是同一个jvm，同一个class字节码，不同的类加载器生成的对象是不同的。  

1.**双亲委派模型**  
从虚拟机角度看：只有两种加载器，一种是启动类加载器，另一种就是其它了。  
站在开发者角度（从上往下）：  
- 启动类加载器：这个很好想，这是程序运行的基础，所有对象的父类object肯定就是在这个阶段加载的嘛。具体路径也就是我们安装jdk时配置的javahome/lib
- 扩展类加载器：为了方便扩展用户自己功能嘛，这个路径在javaome/ext
- 系统类加载器: 将CLASSPATH路径下的类加载到内存中去。  
- 用户类加载器：用户可以扩展自己的类加载器。

双亲委派模型的工作：
- 除了启动类加载器，如果一个类加载器收到加载请求，都会先去询问父类能否加载
- 如果能就让父类加载（在工作范围内找到了对应的类）
- 如果不行自己才会来执行加载动作。  

它的最好的好处就是让类随着加载器具有层次的优先级，说着很绕口，其实就是不会重复加载一个类，这样会保证一些核心类的安全。就比如没有了这个机制，我自己写了个object包丢在classpath路径下，因为启动类加载器中也有一个，那么程序运行将会一片混乱，因为按照java的规定，object只有一个的。
```
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
// 首先，检查请求的类是否已经被加载过了
Class c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}
} catch (ClassNotFoundException e) {
// 如果父类加载器抛出ClassNotFoundException
// 说明父类加载器无法完成加载请求
}
if (c == null) {
// 在父类加载器无法加载时
// 再调用本身的findClass方法来进行类加载
c = findClass(name);
}
}
if (resolve) {
resolveClass(c);
}
 return c;
}
```
双亲委派机制也有被破坏的时候，比较容易理解的就是DriverManager，也就是jdbc是由启动类加载器加载的，但是具体实现的厂商比如mysql是在classpath下面，启动类加载没有办法加载，只好通过一种线程上下文加载器来完成，就是父类加载器让子类去加载一个类。
