## 1.根节点扫描  
jvm中根节点在我理解就是一些常驻且基础的对象，比如类的静态对象属性，还有线程创建的存活栈帧中的局部变量，参数等等，这也很好理解，栈帧是我们正在执行的方法对应的数据结构，里面的对象自然可以看做根对象，一个
特别注意的点就是目前基本上所有垃圾回收器在根节点扫描阶段都会“stop the world”，也很好理解，如果根节点扫描的时候，用户线程没有暂停那么这个扫描结果的准确性是没法保证的。  
但是扫描栈帧本身也是一个很大工作，如果直接去扫描栈帧中每一个值，所以我们能不能用一个数据结构给栈帧中的对象给保存下来呢，可以的，就是`oop(Ordinary  object pointer)`,这样我们扫描的效率就会高很多。  
**这些话可能有误，根节点的扫描主要就是在栈帧上进行的，因为其他一些根对象在class加载的时候几乎都能确定**  

## 2.安全点  
通过oop确实很增大我们的扫描效率，但是如果每一个指令后面都跟一个oop，对空间的需求就会太高了。因此只会在某些指令后面生成oop，这些点成为安全点，也就是说gc并不是任意时候都可以进行的，比如等到正在运行的
线程到安全点的时候才可以，至于安全点的选择标准就是一句话**会不会让程序的执行时间更长**。通用的方式是设置一个标志位和安全点重合，通过一条非常高效的汇编指令来完成。  

## 3.安全区域  
但是上面也有问题，那如果有些线程被sleep或者阻塞了呢，怎么办，**安全区域，在安全区域内引用关系是不会变的**，当线程进行安全区的时候，会标识已经进入了安全区了，如果此时发生了GC，在GC根扫描完成之前，
该线程就要一直等待。  

## 4.记忆集与卡表（map和hashmap的关系）  
记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。问题接踵而至，之前学习就了解到跨代引用的问题，如果在扫描根节点的时候发生了跨代引用呢，不解决这个问题就只有扫描整个老年代了。卡表就是一个字节数组，对一个卡表对应一个内存区域，如果此区域内有跨代引用对象
那么此卡表变脏。为什么用卡表不直接把所有跨代引用对象都用一个数组存储起来，考虑一个效率问题，将粒度缩小一点。这里我的理解就是可能直接保存会包含一些很多我们不需要的信息，我只需要一个能让我知道这对象是不是
跨代引用了就行。  

## 5.写屏障  
一个问题解决了，另一个问题又来了，程序是动态执行的，卡表也不是一成不变，那么卡表的变化谁来维护呢？只要其他分代区域引用了本分代区域的对象，那么对应的卡表就变脏了，这里就一笔带过了，类似spring的AOP一样
在引用类型字段赋值的时候前后一个环绕维护操作。  
还有一个问题就是伪共享，现代的CPU的缓存系统是以缓存行为单位的，并发环境中，如果不加以控制，修改失效或者同步都是一个问题，导致性能降低。就是通过一个卡表标记，不再执行无条件的写屏障了，而通过卡表标记
当卡表标记变脏，说明有其它线程修改卡表但还有某些操作没执行完，当前线程就不能再去修改了。  

## 6.并发的可达性分析。  
这里我直接丢问题和结论了，想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？  
Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决方案：  
- 增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象
了。
- 原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来
进行搜索
