# 垃圾收集器  
1.在jvm虚拟机中，如果一个对象已经“死了”（不可能通过任何途径去使用这个对象了），那么该对象就应该被回收。介绍两种方法：
- 引用计数法：每一个对象有一个引用计数器，引用一次就+1，引用失效-1，为0的时候就不可能再被使用了。很多问题要解决，比如循环依赖等等。
- 可达分析：我的理解就是一些jvm的常驻对象，和当前执行过程的某些对象，包括类的静态成员变量，栈帧中的参数，变量等等，凡是能和上面这些对象有关联的都称作为可达对象；不可达的对象面临被回收的风险，但是同样
距离真正的回收还有一个要考虑的：
    - 如果该对象没有`finalize方法`，或者这个方法已经被调用了，那么该对象没必要执行，直接进行回收
    - 如果有且还没调用，那么会被丢进一个虚拟机创建的`f队列`，不保证何时结束（一旦某个回收过程失败，导致回收系统崩溃），在这个方法中如果一旦和root中的某个对象进行了关联，那么该对象就不会被回收。

2.为了回收方便，将对象进行了划分，有4类：
- 强引用，类似A a=new A,这种，只要强引用关系存在，那么GC就不会回收。
- 软引用，还有一些用但非必须，如果发生溢出之前，会把这些对象列为二次回收。
- 弱引用，只能生存到下一次GC。
- 虚引用，唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。  

# 垃圾回收算法  
在jvm中主流的是追踪垃圾收集。只说“间接垃圾回收”。
1.分代收集理论，是下面即将要讲的3种方法的理论依据，有3条：
- 大多数对象都是朝生夕灭的。
- 熬过次数越多的对象越难以回收。
- 跨代引用相对于同戴引用仅占少数。相互同代引用的对象，应该具有“同死”的特性，如果跨代引用后，当前对象也会进入老年代，而跨代引用就消失了。

2.3种对象回收的思路
- 标记-清除：即对要回收的区域进行一次遍历，将需要回收的对象标记出来，再清除。缺点也很明显，就是当清除过后，形成过多的碎片，导致不得不进行下一次GC。
- 标记-复制：就是将区域分为2个部分，每次只使用其中一个，只有当其中一个满了过了，进行回收，将存活的对象复制到另一块区域。由于大多数新生代对象的生存特性，我们可以将这个区域分为3个部分：
    - 80%的eden区域
    - 2个10%的survive区。只使用eden和一个survive，发生GC时，将这90%的区域存活的对象复制到空的10%的survivie中，如果不幸存活的超过了10%，担保机制就生效了，会从老年代中划一些出来。
- 标记-整理：第一种方法是将标记的进行清除，本方法是将存活的对象向同一个方向移动。缺点就是会造成卡顿。  

具体的使用就权衡利弊了，也可以混合使用。  

# 经典的垃圾回收器  
先丢一张图  
![经典垃圾回收器](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png)  
|  名称   | 算法  | 特性/目标 | 作用代 |
|  ----  | ----  | ---- | ---- |
| serial  | 标记-复制 |  单线程  |  新生代  |
| serial old  | 标记-清理 |   单线程  |  老年代  |
| parNew  | 标记-复制 |  serial的多线程版本  | 新生代   |
| parallel scavenge  | 标记-复制 |   多线程，追求高的吞吐量  |  新生代  |
| parNew old  | 标记-清理 |   多线程  |  老年代  |
| cms（Concurrent Mark Sweep）  | 标记-清理 |   最短回收停顿时间为目标 |    |  
额外：  
cms有四个阶段：  
- 初始标记-标记根节点
- 并发标记-标记引用了根节点的对象（和用户线程并发执行）
- 重新标记-重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
- 标记清除  

三个缺点：  
- 对处理器资源非常敏感

