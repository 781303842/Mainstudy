# Shenandoah收集器（谢兰多尔）  
可以理解为G1的继承者，包括分代理念，region，回收方式，存放大对象都和g1一样，但是有三处比较明显的不同：
- 支持并发的整理算法。（和用户线程一起运行）
- 没有实现分代
- 没有了卡表，用一种类似二维矩阵的东西来表示卡表之间存在的引用关系，比如matrix[A][B]=1表示A region有B region的引用。  

有9个阶段，比较琐碎：
- 初试标记：标记出根节点对象
- 并发标记：通过原始快照的方式进行并发标记（重要）
- 并发清理：将region中一个活对象都没有的清理掉。
- 最终标记：和G1一样，将STAB中少量的引用进行重新标记。并将要回收的region组合成一个collection set
- 并发回收：这里实际上没有回收，只是将活着的对象复制一份到未使用的region中，方式是通过在原对象的对象头结构前加一个`转发指针`，平时指向自己，并发时指向新对象，需要做同步处理，不然用户线程对对象进行
修改可能会在旧对象上。（重要）
- 初试引用更新：这里没有进行引用更新。主要是设置一个安全点，确保所有线程都完成了对象复制任务
- 并发引用更新：线性搜索内存地址将引用改为新对象即可。（对象在堆中的旧地址更新为堆中的新地址）
- 最终引用更新：更新root的引用。（根对象中某些对象可能在回收集中，因此当并发并发回收和并发引用更新后，需要将root中有指向这些新对象的旧对象更改为新对象）（重要）
- 并发清理：经过并发回收和引用更新后，collection set中已经没有存活的对象了，可以清理了。  

# ZGC（z garbage collection）  
定义是：一个使用动态region（动态创建删除region，小 中 大三种容量），不使用分代（意味着不用处理跨代引用了，但是相应要遍历整个堆），使用读屏障，染色指针，虚拟内存多重映射技术的标记-整理算法，目标是低延迟，据说是不会超过10ms。  
**染色指针**：在64位地址的46中将高4位拿出来做一些简单的记录和标记，比如对象移动过？或者只能通过finalize方法访问等等。我的理解就是标记的过程中粒度变小了，并且满足了一些更为复杂的情景（不去访问一个对象，通过对象的引用知道一些和该对象有关的信息）。其它收集器在可达性分析的时候有些通过在对象头标记，有些通过专门的数据结构，都免不了粒度粗需要的额外内存访问。在染色指针中就不会，直接通过该对象的引用就知道了。  
**虚拟内存多重映射到物理内存**：因为在引用上直接通过一些位来放额外的信息，但是对于处理器而言就是一个地址的位而已，所以要通过一些技术将4位不同的虚拟地址都映射到同一个堆对象中，不一定对（**一个未上色的指针，可能在若干操作的后在虚拟内存中有多个虚拟地址，但是这些地址都将映射到同一个物理内存地址**）  
**读屏障**：参考写屏障，读屏障是每当应用程序线程从堆加载引用时运行的代码片段。在读引用操作之前要执行的一些额外的操作。至于为啥用读屏障，一头懵逼。 

大致有4个阶段：
- 并发标记：利用三色法来可达性分析时，和G1和谢兰多尔都要经历初试标记（标记根对象）和最终标记（由于是原始快照的方式需要去更新SATB）都要暂停用户线程，区别在前面的是在对象上标记而ZGC在指针的marked0和marked1上标记。  
- 并发预备重分配： 根据查询条件查询到那些region要清楚，组成一个重分配集，和g1的collection set还是有点不同，G1是计算region后将性价比高的进行一个回收，ZGC只是决定将region中存活的对象复制到其它region中。是在整个堆中根据特定的条件进行扫描。
- 并发重分配：将重分配集中存活的对象复制到新的region中，并在当前的region建立一个转发表，记录从旧引用到新应用的关系。如果用户线程访问了旧引用，就会被内存屏障（不被指令重排序，比如violate关键字）截获，从而访问新引用，并同时修改旧引用为新引用，所以只会在第一次比较慢。这种行为称为指针的`自愈`。  
- 并发重映射：为了不变慢，没太懂。并且当前的重映射是放在下一次GC中的并发标记阶段去做的，这个行为不是很急迫，有自愈的支持。一旦所有旧引用都更新后，就可以将转发表删除了。



