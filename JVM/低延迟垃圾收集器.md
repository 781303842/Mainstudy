# Shenandoah收集器  
可以理解为G1的继承者，包括分代理念，region，回收方式，存放大对象都和g1一样，但是有三处比较明显的不同：
- 支持并发的整理算法。（和用户线程一起运行）
- 没有实现分代
- 没有了卡表，用一种类似二维矩阵的东西来表示卡表之间存在的引用关系，比如matrix[A][B]=1表示A region有B region的引用。  

有9个阶段，比较琐碎：
- 初试标记：标记出根节点对象
- 并发标记：通过原始快照的方式进行并发标记（重要）
- 并发清理：将region中一个活对象都没有的清理掉。
- 最终标记：和G1一样，将STAB中少量的引用进行重新标记。并将要回收的region组合成一个collection set
- 并发回收：这里实际上没有回收，只是将活着的对象复制一份到未使用的region中，方式是通过在原对象的对象头结构前加一个`转发指针`，平时指向自己，并发时指向新对象，需要做同步处理，不然用户线程对对象进行
修改可能会在旧对象上。（重要）
- 初试引用更新：这里没有进行引用更新。主要是设置一个安全点，确保所有线程都完成了对象复制任务
- 并发引用更新：线性搜索内存地址将引用改为新对象即可。（对象在堆中的旧地址更新为堆中的新地址）
- 最终引用更新：更新root的引用。（根对象中某些对象可能在回收集中，因此当并发并发回收和并发引用更新后，需要将root中有指向这些新对象的旧对象更改为新对象）（重要）
- 并发清理：经过并发回收和引用更新后，collection set中已经没有存活的对象了，可以清理了。
