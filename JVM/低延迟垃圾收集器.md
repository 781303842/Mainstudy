# Shenandoah收集器（谢兰多尔）  
可以理解为G1的继承者，包括分代理念，region，回收方式，存放大对象都和g1一样，但是有三处比较明显的不同：
- 支持并发的整理算法。（和用户线程一起运行）
- 没有实现分代
- 没有了卡表，用一种类似二维矩阵的东西来表示卡表之间存在的引用关系，比如matrix[A][B]=1表示A region有B region的引用。  

有9个阶段，比较琐碎：
- 初试标记：标记出根节点对象
- 并发标记：通过原始快照的方式进行并发标记（重要）
- 并发清理：将region中一个活对象都没有的清理掉。
- 最终标记：和G1一样，将STAB中少量的引用进行重新标记。并将要回收的region组合成一个collection set
- 并发回收：这里实际上没有回收，只是将活着的对象复制一份到未使用的region中，方式是通过在原对象的对象头结构前加一个`转发指针`，平时指向自己，并发时指向新对象，需要做同步处理，不然用户线程对对象进行
修改可能会在旧对象上。（重要）
- 初试引用更新：这里没有进行引用更新。主要是设置一个安全点，确保所有线程都完成了对象复制任务
- 并发引用更新：线性搜索内存地址将引用改为新对象即可。（对象在堆中的旧地址更新为堆中的新地址）
- 最终引用更新：更新root的引用。（根对象中某些对象可能在回收集中，因此当并发并发回收和并发引用更新后，需要将root中有指向这些新对象的旧对象更改为新对象）（重要）
- 并发清理：经过并发回收和引用更新后，collection set中已经没有存活的对象了，可以清理了。  

# ZGC（z garbage collection）  
定义是：一个使用动态region（动态创建删除region，小 中 大三种容量），不使用分代（意味着不用处理跨代引用了，但是相应要遍历整个堆），使用读屏障，染色指针，虚拟内存多重映射技术的标记-整理算法，目标是低延迟，据说是不会超过10ms。  
**染色指针**：在64位地址的46中将高4位拿出来做一些简单的记录和标记，比如对象移动过？或者只能通过finalize方法访问等等。我的理解就是标记的过程中粒度变小了，并且满足了一些更为复杂的情景（不去访问一个对象，通过对象的引用知道一些和该对象有关的信息）。其它收集器在可达性分析的时候有些通过在对象头标记，有些通过专门的数据结构，都免不了粒度粗需要的额外内存访问。在染色指针中就不会，直接通过该对象的引用就知道了。  
**虚拟内存多重映射到物理内存**：因为在引用上直接通过一些位来放额外的信息，但是对于处理器而言就是一个地址的位而已，所以要通过一些技术将4位不同的虚拟地址都映射到同一个堆对象中，不一定对（**一个未上色的指针，可能在若干操作的后在虚拟内存中有多个虚拟地址，但是这些地址都将映射到同一个物理内存地址**）  
**读屏障**：参考写屏障，读屏障（根据gc所处的阶段不同（保存在全局变量ZGlobalPhase中），读屏障要不是标记、要不就是重新分配那些没有标记或者没有重新映射的对象）是每当应用程序线程从堆加载引用时运行的代码片段。在读引用操作之前要执行的一些额外的操作。至于为啥用读屏障，一头懵逼。 

大致有4个阶段：
- 并发标记：利用三色法来可达性分析时，和G1和谢兰多尔都要经历初试标记（标记根对象）和最终标记（由于是原始快照的方式需要去更新SATB）都要暂停用户线程，区别在前面的是在对象上标记而ZGC在指针的marked0和marked1上标记。  
- 并发预备重分配： 根据查询条件查询到那些region要清楚，组成一个重分配集，和g1的collection set还是有点不同，G1是计算region后将性价比高的进行一个回收，ZGC只是决定将region中存活的对象复制到其它region中。是在整个堆中根据特定的条件进行扫描。
- 并发重分配：将重分配集中存活的对象复制到新的region中，并在当前的region建立一个转发表，记录从旧引用到新应用的关系。如果用户线程访问了旧引用，就会被内存屏障（不被指令重排序，比如violate关键字）截获，从而访问新引用，并同时修改旧引用为新引用，所以只会在第一次比较慢。这种行为称为指针的`自愈`。  
- 并发重映射：为了不变慢，没太懂（猜测：如果重分配集中每一个对象都通过内存屏障来达到更新引用的效用，那么次数一多后，可能效率也会下降，但是整体更新操作不是很急，综合考虑，所以还需要一个并发重映射阶段）。并且当前的重映射是放在下一次GC中的并发标记阶段去做的，这个行为不是很急迫，有自愈的支持。一旦所有旧引用都更新后，就可以将转发表删除了。  


**缺点**：要对整个堆进行一个扫描处理，如果这个过程中产生了大量的新对象（浮动垃圾，在标记结束后产生的，参考cms），长期如此，回收的效率就跟不上创建的效率了，一个解决方案还是引用分代收集。  
**优点**：NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构多核处理器，每个处理器的内存管理器都有自己管理的内存区域，如果要访问其他处理器管理的区域就得通过Inter-Connect通道来完成，这要比访问处理器的本地内存慢得多。NUMA会优先考虑在当前处理器的本地内存上分配对象。



