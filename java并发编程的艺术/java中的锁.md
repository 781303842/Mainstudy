# lock和synchronize  
1.synchronize是关键字，是jvm层次的，默认是通过加入mointerenter和mointerexit两个指令来完成同步操作。默认实现的锁的获取和释放，也是可以重进入（同一个线程），非公平的锁。在之前的jdk版本中synchronize
是一个比较重量级的锁，不细分情况直接加锁，而现在synchronize引用了偏向锁，轻量级锁，重量级锁也达到了一个很好地效果。
预备知识：加锁的时候会将对象头中的mark word部分通过cas操作拷贝一份到当前栈帧中锁记录的空间，并将这条记录指向对象，对象的mark word指向当前栈帧的锁记录中的displace mark word。  

- 偏向锁：在实际运行中获取线程的对象再次获取该对象的几率很大，因此访问同一个同步块的时候，只需要简单比较一个对象头中Mark Word里是否存储着指向当前线程的偏向锁即可。
- 轻量级：通过CAS将对象头的mark word指向当前栈帧中的锁记录区域，如果失败表示存在锁竞争，失败的线程通过自旋来尝试加锁。
- 重量级：当前锁释放的时候通过CAS如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。  

虽然synchronize经过优化过后，已经得到了很大的提升，但是也有一些缺点，比如最要命的就是把锁的获取和释放固化了，也就决定了synchronize无法处理一些灵活的操作，比如先获得锁A，然后再获取锁B，当锁B获得
后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D。而且synchronize不能响应中断。lock接口实现的同步组件能够响应中断。所以lock接口的作用就相当于让我们更灵活的处理一些并发情况。并且可以超时获取锁，也就是如果在指定时间内没获取到锁，就自动返回。  

# AQS（abstract queue synchronize）同步器  
定义：实现其它同步组件的基础，实现是通过维护内部一个int类型的同步状态变量，通过三个方法setState,casSetState，setstate来维护，并且内部的数据结构是一个FIFO的双向链表的同步队列。
- 当线程尝试通过tryacquire方法获取同步状态，如果成功就执行其它后续操作，如果失败则通过通过CAS操作构造一个表示当前阻塞线程的同步节点添加到同步队列的末尾。
- 只有当前节点是头结点时才会去尝试获取同步状态，不然一直处于自旋的状态。
- 首节点的释放会唤醒后置节点，因为首节点已经是获取了同步状态的线程，所以直接将同步队列的head的next指向下一个节点即可。
