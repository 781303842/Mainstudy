# 线程简介
1.进程：可以看成程序（代码，数据，文档）在某个数据上的一次运行，也可以认为是程序的载体，是动态的，系统进行资源分配和调度的基本单位。  
2.线程：一个进程有多个线程，线程可以看成cpu处理的最小单位，看成进程子任务的控制流。程序执行的最小单位。  
3.为什么要使用多线程？
- 在合理的使用下，能尽可能的使用多核处理器。
- 更好的响应时间。  

4.线程的状态：初始（创建好还没start），运行，阻塞（阻塞于锁），等待状态（等待其它线程唤醒），终止。  
5.守护线程：因为它主要被用作程序中后台调度以及支持性工作，如果jvm中不存在非守护进程，jvm虚拟机会退出。   
6.线程的中断标志位，其它线程能通过interrupt来使当前线程发生中断，并且当前线程能通过isinterrupt属性判断是否被中断了。  
7.如果一个线程A执行了thread.join方法，那么A会等到thread返回结果后才会继续执行。  
8.ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值

# 过期suspend（暂停） resume（恢复） stop（停止）方法（不被推荐）  
1.suspend方法调用后，不会释放占用资源，可能出现死锁。  
2.stop方法类似，但是停止的时候比较粗暴，没给线完成释放资源的机会。  
3.**推荐使用线程中断标志和中断标志量来终止线程**  

# 线程的通讯  
1.等待通知机制，是指一个线程`调用对象A`的wait方法进行等待状态，只有当其它线程`调用A对象`notify方法唤醒一个线程或者notifyall方法唤醒线程。在使用notify，wait，notifyall注意的细节：
- 上述操作都要加锁
- 调用wait方法后，线程有running变为waiting，同时将该线程放置到`对象的等待队列`，锁的是谁，自然等待的时候为了区分就直接放线程组成等待节点放入对应对象的等待队列（object都是一个同步队列，一个等待队列，而condition则是一个同步队列，多个等待队列）。
- 调用notify后者notify方法后，线程不会从wait立即返回，而是等通知线程释放锁后，有机会返回。
- notify方法就是将等待队列中的首节点表示的线程移动到同步队列的末尾，并参与到同步状态的竞争，只有当前节点的前驱节点是头结点时才会去竞争，不然该节点就会阻塞。
- 从wait方法返回的前提是获取了锁。  

![notify工作流程](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/notify%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)  




