# java并发机制的底层实现原理  
## 1.volatile的应用  
- 保证了对共享变量的可见性，也就是当我对volatile对一个变量进行修饰的时候，某个线程对该变量进行修改后，其它线程能立即感知，但是我们要知道**volatile并不是线程安全的**，一个不严谨的例子就是多个线程对同一个变量进行自增操作，volatile只能保证线程取出来的变量值，此时是正确的，如果在当前线程自增的同时，其它线程已经执行完自增操作，那么当前的值就过期了，并且可能把较小的值写回了变量。  
- 禁止指令重排序优化，假设有两个线程，一个A和一个B，其中B线程要依赖于A线程中的某些信息，因此B线程需要一个标志位来判断A是否执行完毕，这个时候A线程中执行代码的标志位可能会被提前执行，导致了B中需要的某些信息未就绪，导致bug。  

## 2.volatile的实现原理  
在多核处理器下，volatile会在变量的汇编指令前加上lock指令，做了两件事。  
- 将当前处理器缓存行数据写回系统内存  
- 这个写回操作会使其它线程缓存了该地址的数据失效  

## 3.synchronize的实现原理与应用  
java中的每一个对象都可以作为锁。
实现锁的基础，三种表现形式：  
- 对于普通同步方法，锁的是this对象  
- 对于普通静态同步方法，锁的是当前class的字节码文件  
- 对于同步代码块，锁的事synchronize括号里配置的对象  
代码同步和方法同步都可以通过**monitorenter，monitorexit**两条指令完成。  

## 4.锁升级  
无锁，轻量级锁，偏向锁，重量级锁，可以升级锁，但不能降级。  
 - 偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，
持有偏向锁的线程才会释放锁  
 - 轻量级锁：以hotpot对象头有两部分信息，一个是自身运行的信息（也成mark word），一个是存储指向方法区对象类型数据的指针；其中进入同步块的时候会检查如果该同步对象没有被锁定（锁标志位01），虚拟机首先在当前线程的栈中填加一个lock record的记录，用于存储锁对象的mark word，并加一个displace前缀，如下图；然后通过CAS将该对象的mark word更新为指向lock record的指针，成功就锁定好，失败则表明多个线程在竞争该锁，上升为重量级锁。  
 ![markword](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/markword.png)
 ![markword](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%A0%86%E6%A0%88.png)
 ## 5.锁比较  
 ![锁的优缺点比较](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83.png)
