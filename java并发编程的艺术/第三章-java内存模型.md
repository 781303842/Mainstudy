# java内存模型  
## java内存模型的基础  
并发编程有两个需要解决的问题：
1. 线程间如何通信，方式有两种：  
  - 共享内存：线程之间共享程序的公共状态进行隐私通信，同步在此种模式下是显示进行的，某个代码或者代码块互斥执行。  
  - 消息传递：线程间发送消息进行显示通信，同步是隐式的。
2. 线程间如何同步  
在java中采取的共享内存模式，因此线程通信是隐式的，所以如果不清楚过程，很可能导致找不到bug的原因。  
## java内存模型的抽象结构   
java线程间的通信是由jmm控制的，jmm决定了一个线程对实例域，静态域，数组元素写入何时对另一个线程可见。线程之间的共享内容存储在主内存中，每个线程都有一个本地的私有内存（jmm抽象的，实际不存在，可能由一些缓存
构成），存储的主内存的共享内容的副本。因此如果两个线程要通信的话，要经过以下两个阶段：  
- A线程将本地内存更新后的变量内容刷新到主内存中去  
- B线程去主内存中读取线程A之前已经更新过的共享内容  
## 从源代码到指令的重排序  
1.编译器优化的重排序：编译器在不影响单线程程序语意的的前提下，可以改变语句的执行顺序；这里我的理解就是比如int a=1;int b=1；没有影响；但是int a=1;a++;int c=a+1;这里如果a++先执行那么结果就不对了。
2.指令级并行的重排序：如果指令之间不存在依赖，这里的依赖可以参考上面的第二个例子，那么可以通过并行技术，将多条指令一起执行。  
3.内存系统的重排序：处理器使用写缓存和读/写缓存，这使得加载和存储操作看上去是乱序执行。  
从java源代码到最终实际执行的执行序列，会经历以上三种重排序。
