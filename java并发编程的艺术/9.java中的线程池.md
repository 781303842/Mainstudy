# 线程池的使用  
1.使用线程池的好处
- 降低系统资源的使用，避免频繁的创建和销毁线程带来的性能开销
- 提高任务的响应速度，当任务到达时，如果刚好有空闲线程，则可以直接执行。
- 便于对进程的管理。  

2.线程池的使用流程  
- 当任务到达时，首先判断核心线程池是否已经满了，这里的满了是指核心线程数量是否超过了`corepoolsize`的规定，如果没有，则创建工作线程来执行任务；如果满了进入下一步
- 如果核心线程池已经满了，则判断工作队列是否已满，如果工作队列没满，则将任务加入到工作队列，由工作现场执行完其它任务后会循环处理工作队列。
- 如果工作队列也满了，判断普通线程池是否满了，如果没满，创建一个普通线程池来完成工作，如果普通线程池也满了，超过了`maxpoolsize`，则交由饱和策略处理。  
- 核心线程池可以看成普通线程池的子区域，为什么这么设计呢？首先在创建线程的时候会获得全局锁，如果次数多了，就成为了性能瓶颈，所以一般都希望有一个合适的线程数量来处理任务，这个就是核心线程池，但是
总要有一个队列来放还来不及处理的任务，一般推荐有界队列，防止队列过大导致资源异常，程序崩溃；如果这样还不行，那就只有再创建线程了，但是有一个度。另外就是为什么不直接都当做核心线程，如果线程多了，对
系统资源消耗也很大。所以折中处理。
![处理流程](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)
![执行流程](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)   

3.线程池的使用  
```
new ThreadPoolExecutor(corePoolSize,//核心线程池数量
                        maximumPoolSize, //最大线程池数量
                        keepAliveTime,//线程空闲时最大的存活时间
                        milliseconds,//上面的单位，可以是秒或者毫秒
                        runnableTaskQueue, //等待队列。一般使用有界队列
                        handler);//饱和策略处理器。1，抛出异常 2.让任务申请线程去完成任务的执行 3.                                                                         
```
