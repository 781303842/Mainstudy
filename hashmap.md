# 2020.3.10 hashmap学习记录  

**hashmap的一些关键点**  
hashmap 采用的数据结构在jdk1.7的时候采用数组+链表的组合来实现，在jdk1.8中是数组+链表+红黑树来实现。另外在jdk1.7中，hashmap有几个地方需要关注一下  
**1 提高性能**  
hashmap默认数组长度为16，也就是2<<4,hashmap中分配或者查找的过程是用key的hash值与数组长度做求余运算，一般而言我们会用%来实现求余运算，也就是hash（key）%arr.length，但是查看源码的过程中发现，jdk1.7中是用&符号来实现的，先抛出一个结论，数组长度为2^n时候，hash（key）%arr.length与hash（key）&（arr.length-1）是一致，并且当数组长度是2的幂次的时候性能更佳，我们举两个例子就能看出差别了。引用一张别人画的图。
![alt 属性文本](https://github.com/781303842/Mainstudy/blob/master/hashmap.png)
看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行与运算，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，为什么呢，比如说0010和0011与后者与运算后，只会得到0010，因此0011不会被用到，其它同理，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。  `在jdk1.8中hash方法已经改为(h = key.hashCode()) ^ (h >>> 16)`  
**2 方便定位**  
（下面的内容不考虑红黑树）hashmap扩容时是乘2，按照上面来说就是从数组长度2<<4变成了2<<5，扩容后需要重新将元素定位，公式不变还是key.hashcode & (array.length - 1)，因此2<<5-1就等于11111，比原来的1111多了一位，那么如果与运算的时候多的高位为0，那么元素的位置依然是原来的位置，如果为1那么元素新的位置就是原来的低4位组成的原index，多出来的高位1按规则为16，所以新的位置就等于`原来的索引+原来的数组长度`。
