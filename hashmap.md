# 2020.3.10 hashmap学习记录  

**hashmap的一些关键点**  
hashmap 采用的数据结构在jdk1.7的时候采用数组+链表的组合来实现，在jdk1.8中是数组+链表+红黑树来实现。另外在jdk1.7中，hashmap有几个地方需要关注一下  
**1 提高性能**  
hashmap默认数组长度为16，也就是2<<4,hashmap中分配或者查找的过程是用key的hash值与数组长度做求余运算，一般而言我们会用%来实现求余运算，也就是hash（key）%arr.length，但是查看源码的过程中发现，jdk1.7中是用&符号来实现的，先抛出一个结论，数组长度为2^n时候，hash（key）%arr.length与hash（key）&（arr.length-1）是一致，并且当数组长度是2的幂次的时候性能更佳，我们举两个例子就能看出差别了。引用一张别人画的图。
![alt 属性文本](https://github.com/781303842/Mainstudy/blob/master/hashmap.png)
看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行与运算，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，为什么呢，比如说0010和0011与后者与运算后，只会得到0010，因此0011不会被用到，其它同理，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。  `在jdk1.8中hash方法已经改为(h = key.hashCode()) ^ (h >>> 16)还是为了减少碰撞，提高性能`  
**2 方便定位**  
（下面的内容不考虑红黑树）hashmap扩容时是乘2，按照上面来说就是从数组长度2<<4变成了2<<5，扩容后需要重新将元素定位，公式不变还是key.hashcode & (array.length - 1)，因此2<<5-1就等于11111，比原来的1111多了一位，那么如果与运算的时候多的高位为0，那么元素的位置依然是原来的位置，如果为1那么元素新的位置就是原来的低4位组成的原index，多出来的高位1按规则为16，所以新的位置就等于`原来的索引+原来的数组长度`。  
**3 jdk1.7扩容死锁**  
特别提醒：对象绝大多数情况下都是分配在堆中的，因此若数组中的元素是对象类型，那么数组中实际存放的是对象的引用，这里我们可以粗矿把当前数组中的元素存放的是一个32的内存地址。在jdk1.7中如果hashmap按2倍扩容时可能发生死锁，我们来分析一下具体原因，关于扩容的具体代码我就不上传了。我们都知道jdk1.7中采用数据+链表的结构完成hashmap，假设我们现在正在扩容，思路简单，两层循环，设current_node是我们当前的正在循环的数组元素，也可以理解为头结点，然后我们计算出当前节点数据在新数组中的位置，然后用current_node.next=newarr[hash(key)&(newlength-1)],如果新数组的此位置没有节点，那么current_node.next=null，然后newarr[hash(key)&newlength-1]=current_node.我们再来看一遍这个过程，当老数组拿到当前元素在新数组中的位置的时候，首先当前元素根据自身引用找到堆中具体存放的对象，然后修改自己对象的next为之前对象的引用。如果新位置没有元素那么next=null。然后我们将当前节点（也是一个对象引用）赋值给新数组的新位置，那么这个位置所存放的之前对象的引用将被当前节点的引用所取代。`进入正题`，如果上述过程不是在单线程，而是在多线程的情况下，会发生什么呢，比如有两个线程都执行到了current_node节点，两个线程中的current_node是一样的，那么线程2先暂停，线程1先执行，执行完的结果可能也不尽人意，某个数组位置还是有链表，并且对应之前老数组中某个位置的的链表中的一部分且是逆序,这个时候线程2被唤醒，然后使当前位置链表中最后一个元素又指向了当前位置，形成了死循环。  
**4 补充**  
为什么1中会有hash（key）%arr.length与hash（key）&（arr.length-1）是一致  
举个例子：
假如 array.length = 2^4 = 16，二进制10000。这个数减去1的结果是1111，也就是array.length -1 = 1111。
（下面这段中的数字都是二进制）
再假设一个key的值为10011011001（很随意写的一个数），与1111做 & 操作，得到的结果是1001（高位部分1001101都舍去了）。而1001必然是一个小于10000的数，对于一个小于10000的数而言，1001 % 10000得到的就是1001自己。
那么刚刚舍弃的高位部分1001101 0000（后面补上了四个0000）就一定能被10000整除吗？答案是肯定的：因为10011010000可以拆成10000000000+10000000+1000000+10000，这几个数都能通过10000的n次左移得到，也就相当于这几个数都能被10000整除。那他们的和，也就是10011010000，一定也可以被10000整除。
因此，最终结论就是：10011011001 & ( 10000 - 1 ) = 10011011001 & 1111 = 1001 = 10011011001 % 10000
