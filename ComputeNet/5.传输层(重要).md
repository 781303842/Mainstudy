# 传输层的功能  
- 传输层提供的事进程之间的逻辑通讯（端到端），网络层提供的是主机之间的逻辑通讯。因此网络层只给出了源ip和目的ip，虽然从实际上来说也是进程的通讯，也就是好像这两个进程直接通讯了一样，叫逻辑通讯
- 复用是指不同的进程都可以使用传输层协议进行数据发送；分用是指数据在传输层解析后能传递给对应的进程；（网络层的复用只是指可以用不同的协议都可以封装成ip数据报发送出去）
- 传输层还要校验数据首部和数据，网络层只校验首部
- 提供两种不同的协议，面向连接的UDP和面a向无连接的TCP；（网络层要么是实现连接的虚电路，要么是无连接的数据报，不能同时存在）  
- 传输层向上层屏蔽了网络核心的细节，比如网络结构和协议，让进程好像在传输层有一条实体供两边进程通讯，实际上没有，所以叫逻辑。当采用tcp时就算下面的不可靠，传输层也是可靠的，二者是一个包含的关系。层次不同

# 传输层的寻址与端口  
1.端口：就是让数据通过该端口知道是那个进程发的，或者应该交由那个进程接收。（网络层是ip，链路层是mac）  
一些常用的端口号：`ftp：21，telent：23，smtp：25，dns：53，tftp：69，http：80`  

2、套接字（ip地址：端口）用来标志一个唯一的主机和上面的进程。  

# UDP  
1.udp是无连接的，为什么有了连接可靠的TCP，还要在udp开发应用呢，比如有一些场景不需要可靠，只需要尽可能的将数据发送出去，比如直播，用udp就比较好。udp首部仅8字节，tcp有20字节。dp也不需要做拥塞控制。  

2.udp首部格式  
![udp首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/udp.png)  
- 源端口和目的端口都是一个字节
- 首部长度：一个字节，包含首部和数据
- 校验和：检查udp数据报传输中是否有差错。有错就丢掉。校验时会添加一个伪首付，凑足20字节，这个伪首部只在校验时用。  

![伪首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E4%BC%AA%E9%A6%96%E9%83%A8.png)  


# TCP  
1.tcp是在不可靠的ip层上实现可靠传输，解决传输的可靠，有序，无丢失和无重复的问题。特点：
- 面向连接的传输层协议  
- tcp连接只能一对一
- tcp保证可靠的交付。并且提供全双工通信
- tcp是面向字节流的，虽然应用层传递下来的数据是一块一块的，但是tcp认为这还是字节流。  

2.tcp报文首部  
![tcp首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/tcp%E9%A6%96%E9%83%A8.png)  
- tcp首部固定20字节，后面可选
- 源端口和目的端口都是2字节，是传输层和应用层的服务接口
- 序号字段（4字节），因为tcp是面向字节流的，因为对一个一个的字节编号，序号是指本报文段第一个字符的序号
- 确认号（4字节），表示期望收到对方的数据报的第一个字符号，比如N，则表示N-1都已经正确接收了。
- 数据偏移（4比特位），不是网络层分片的那个便宜，而是tcp数据起始地址离tcp首部起始地址有多远。  
- 保留字段（6比特位）。
- 紧急位（1位）：如果为1表示有效，并且当前报文段有紧急数据要紧急传输。
- 确认位（1位）：只有当确认位为1时，即ACK=1,确认号才有效。
- 推送位（1位）：如果推送位为1，则接收方不用等缓存填满了再交付，而是尽快交付。
- 复位位（1位）：如果为1，表示当前tcp连接出现了错误，需要释放连接再重新连接
- 同步位（1位）：为1的时候表示这是一个连接请求或者连接接收报文
- 终止位（1位）：表示此报文段的发送方数据已经发送完了，要求释放传输连接。
- 窗口字段（2字节）：表示允许对方发送的数据量大小，因为接收方的缓存区是有限的。
- 校验和（2字节）：和udp一样，也要加上12字节的伪首部
- 紧急指针字段（16位）：指出本报文段有多少紧急数据，紧急数据都是放在报文段前面的。和前面的紧急位配合使用
- 选项字段：长度可变，最大报文长度（max segment size，mss）。mss是tcp报文中数据部分的最大长度
- 填充字段：这是为了使整个首部长度是4字节的整数倍。  

3.tcp连接管理  
三个阶段：连接建立，数据传输，释放连接；要解决几个问题：1.要确认对方的存在，2.允许协商一些参数，比如发送窗口大小等等 3.tcp的连接是通过套接字来完成建立的。  

3.1 tcp建立连接（**三次握手**）  
![三次握手](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)  
1.客户机发送一个连接请求报文，注意不包含应用层的数据，发送的为`SYN=1，seq=x`,其中x是随机的一个字符序号  
2.服务机接收到连接请求报文后，**为tcp连接分配tcp缓存和变量，因此服务器容易受到洪泛攻击**，回送一个数据`SYN=1,ACK=1,ack=x+1,seq=y`,ACK是确认位有效与否的标志，ack是表示期望下一次收到的报文段第一个字符的序号  
3.客户机接收到确认报文段后，回送一个`SYN=1,ACK=1,seq=x+1,ack=y+1`，**为tcp连接分配tcp缓存和变量**  
上面的步骤完成后，tcp连接就建立成功了，是全双工的，因此任何一方都可以发送接收数据。  

4.tcp连接的释放  
![tcp连接的释放](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png)   
1.客户机发送一个连接释放报文，包含`FIN=1,seq=x`  
2.服务机收到释放报文后，回送一个`ACK=1,ack=x+1,seq=u`，这个时候客户机到服务机的连接已经关了，但是服务器向客户机发送消息，客户机还是要接收，服务机处于半关闭状态  
3.服务机已经处理完收发任务了，回送一个`FIN=1,ACK=1,ack=x+1,seq=v`
4.客户机收到服务器的确认释放报文后，回送一个`ACK=1,seq=x+1,ack=v+1`，这个时候连接还没完全释放，必须等到2个msl后，连接才关闭（这里有知识点）  

