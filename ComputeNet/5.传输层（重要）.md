# 传输层的功能  
- 传输层提供的事进程之间的逻辑通讯（端到端），网络层提供的是主机之间的逻辑通讯。因此网络层只给出了源ip和目的ip，虽然从实际上来说也是进程的通讯，也就是好像这两个进程直接通讯了一样，叫逻辑通讯
- 复用是指不同的进程都可以使用传输层协议进行数据发送；分用是指数据在传输层解析后能传递给对应的进程；（网络层的复用只是指可以用不同的协议都可以封装成ip数据报发送出去）
- 传输层还要校验数据首部和数据，网络层只校验首部
- 提供两种不同的协议，面向连接的UDP和面a向无连接的TCP；（网络层要么是实现连接的虚电路，要么是无连接的数据报，不能同时存在）  
- 传输层向上层屏蔽了网络核心的细节，比如网络结构和协议，让进程好像在传输层有一条实体供两边进程通讯，实际上没有，所以叫逻辑。当采用tcp时就算下面的不可靠，传输层也是可靠的，二者是一个包含的关系。层次不同

# 传输层的寻址与端口  
1.端口：就是让数据通过该端口知道是那个进程发的，或者应该交由那个进程接收。（网络层是ip，链路层是mac）  
一些常用的端口号：`ftp：21，telent：23，smtp：25，dns：53，tftp：69，http：80`  

2、套接字（ip地址：端口）用来标志一个唯一的主机和上面的进程。  

# UDP  
1.udp是无连接的，为什么有了连接可靠的TCP，还要在udp开发应用呢，比如有一些场景不需要可靠，只需要尽可能的将数据发送出去，比如直播，用udp就比较好。udp首部仅8字节，tcp有20字节。dp也不需要做拥塞控制。  

2.udp首部格式  
![udp首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/udp.png)  
- 源端口和目的端口都是一个字节
- 首部长度：一个字节，包含首部和数据
- 校验和：检查udp数据报传输中是否有差错。有错就丢掉。校验时会添加一个伪首付，凑足20字节，这个伪首部只在校验时用。  

![伪首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E4%BC%AA%E9%A6%96%E9%83%A8.png)  


# TCP  
1.tcp是在不可靠的ip层上实现可靠传输，解决传输的可靠，有序，无丢失和无重复的问题。特点：
- 面向连接的传输层协议  
- tcp连接只能一对一
- tcp保证可靠的交付。并且提供全双工通信
- tcp是面向字节流的，虽然应用层传递下来的数据是一块一块的，但是tcp认为这还是字节流。  

2.tcp报文首部  
![tcp首部](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/tcp%E9%A6%96%E9%83%A8.png)  
- tcp首部固定20字节，后面可选
- 源端口和目的端口都是2字节，是传输层和应用层的服务接口
- 序号字段（4字节），因为tcp是面向字节流的，因为对一个一个的字节编号，序号是指本报文段第一个字符的序号
- 确认号（4字节），表示期望收到对方的数据报的第一个字符号，比如N，则表示N-1都已经正确接收了。
- 数据偏移（4比特位），不是网络层分片的那个便宜，而是tcp数据起始地址离tcp首部起始地址有多远。  
- 保留字段（6比特位）。
- 紧急位（1位）：如果为1表示有效，并且当前报文段有紧急数据要紧急传输。
- 确认位（1位）：只有当确认位为1时，即ACK=1,确认号才有效。
- 推送位（1位）：如果推送位为1，则接收方不用等缓存填满了再交付，而是尽快交付。
- 复位位（1位）：如果为1，表示当前tcp连接出现了错误，需要释放连接再重新连接
- 同步位（1位）：为1的时候表示这是一个连接请求或者连接接收报文
- 终止位（1位）：表示此报文段的发送方数据已经发送完了，要求释放传输连接。
- 窗口字段（2字节）：表示允许对方发送的数据量大小，因为接收方的缓存区是有限的。
- 校验和（2字节）：和udp一样，也要加上12字节的伪首部
- 紧急指针字段（16位）：指出本报文段有多少紧急数据，紧急数据都是放在报文段前面的。和前面的紧急位配合使用
- 选项字段：长度可变，最大报文长度（max segment size，mss）。mss是tcp报文中数据部分的最大长度
- 填充字段：这是为了使整个首部长度是4字节的整数倍。  

3.tcp连接管理  
三个阶段：连接建立，数据传输，释放连接；要解决几个问题：1.要确认对方的存在，2.允许协商一些参数，比如发送窗口大小等等 3.tcp的连接是通过套接字来完成建立的。  

3.1 tcp建立连接（**三次握手**）  
![三次握手](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)  
1.客户机发送一个连接请求报文，注意不包含应用层的数据，发送的为`SYN=1，seq=x`,其中x是随机的一个字符序号  
2.服务机接收到连接请求报文后，**为tcp连接分配tcp缓存和变量，因此服务器容易受到洪泛攻击**，回送一个数据`SYN=1,ACK=1,ack=x+1,seq=y`,ACK是确认位有效与否的标志，ack是表示期望下一次收到的报文段第一个字符的序号  
3.客户机接收到确认报文段后，回送一个`SYN=1,ACK=1,seq=x+1,ack=y+1`，**为tcp连接分配tcp缓存和变量**  
上面的步骤完成后，tcp连接就建立成功了，是全双工的，因此任何一方都可以发送接收数据。  

4.tcp连接的释放  
![tcp连接的释放](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/4%E6%AC%A1%E6%8C%A5%E6%89%8B.png)   
1.客户机发送一个连接释放报文，包含`FIN=1,seq=x`  
2.服务机收到释放报文后，回送一个`ACK=1,ack=x+1,seq=u`，这个时候客户机到服务机的连接已经关了，但是服务器向客户机发送消息，客户机还是要接收，服务机处于半关闭状态  
3.服务机已经处理完收发任务了，回送一个`FIN=1,ACK=1,ack=x+1,seq=v`
4.客户机收到服务器的确认释放报文后，回送一个`ACK=1,seq=x+1,ack=v+1`，这个时候连接还没完全释放，必须等到2个msl后，连接才关闭（这里有知识点） 

5.tcp的可靠传输  
tcp的可靠传输就是让发送的字节和接收方接收的字节一样，包括顺序等等。通过`校验，序号，确认，重传`达到这个目的。序号和确认校验就不多说了，主要是重传，有两种机制：
- 超时重传：为每一个数据报计时，只要这个时间到了还没收到确认，就重发。是以RTT(round-trip time)为基础计算出一个时间，rtt就是数据报从发出到收到确认的时间。
- 冗余ACK：发送方可以在超时时间之前通过冗余的ACK来检查丢包情况；比如A发送了1,2，3,4报文段;其中B接收到了1,3,4,其中2丢失了。**TCP规定每当收到比期望序号大的字报文段时就发送一个冗余ACK，表明希望收到的字节，**，同时**TCP还规定，发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这被确认的报文段后面的报文段已经丢失了。**  

6.TCP流量控制  

**接收方**通过动态调整发送方的滑动窗口大小，这就是接收串口rwnd，即动态调整tcp报文段首部的窗口字段；同时**发送方**通过网络的情况预估出一个窗口值，称为拥塞窗口cwnd。取值为min(rwnd,cwnd)。
和链路层的流量控制区别在于，链路层控制的是直连的两个节点，传输层控制的两个端，并且链路层中滑动窗口大小不能动态调整。可以说控制的对象和层次不一样。  

7.TCP的拥塞控制  
拥塞控制是防止过多的数据涌入网络，导致网络的通信效率降低，但是两个端点并不能知道网络的拥塞情况，只是知道发送数据的时间花的更久了。拥塞控制是一个全局的，包括所有的主机和路由器，是对整个通讯子网的一个控制，而流量控制是点对点通信量的控制。为了更好地进行拥塞控制，定义了以下几种算法：
- 慢开始：在TCP刚连接的时候，令拥塞窗口大小为1，因此可以发送一个报文段，当收到报文段的确认后，拥塞窗口大小变为2，以此类推直到到达了慢开始规定的阀值，就到了拥塞避免算法了。
- 拥塞避免：拥塞避免就是不是加倍了，而是线性增加，每当遇到一次超时（没有按时收到确认）的时候，将当前慢开始门限阀值调整为当前拥塞窗口的一半，拥塞窗口重置为1。如果拥塞窗口又小于了慢开始的阀值，则又使用加倍方式。
- 快重传：也可以用于拥塞处理，当连续收到三个冗余的ACK，因为丢包了肯定意味着网络堵塞嘛，直接重传接收方尚未收到的报文段。
- 快恢复：当发送端连续收到三个冗余ACK，则直接将慢开始阀值设置为当前拥塞窗口一半，但是拥塞窗口的值也设置为新的门限值，这是和拥塞避免的区别。
