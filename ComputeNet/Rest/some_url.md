# tcp三次握手4次挥手  
## 三次握手  
网上关于tcp三次的图已经很多了，这里只是记录同时检测自己对tcp三次握手的掌握程度。  
1.clietn发送一个SYN=1,seq=c，此时client处于SYN_SEND状态。  
2.server接收到client发送来的请求连接，也要回复并确认，发送ACK=1,SYN=1,seq=s,ack=c+1,服务器端处理SYN_RECIEVE状态。  
3.client接收到服务器端发送回来的信息，并回复确认信息，ACK=1,seq=c+1,ack=s+1,连接建立完成。  
**一些常见的问题**  
1.为什么tcp是三次握手不是两次握手。  
计网中说的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。其实我的理解就是会引起一些混乱而导致错误。比如A客户端像B服务器发起请求连接，但是由于网络拥堵导致请求连接未能到达服务器端，根据一些机制A可能会重新发送一个连接请求，而此次的连接服务器端接受到了，也发送了应答消息，此时又分为两种情况。1.应答消息接受成功，那么双方正常通讯，此时第一次失效的连接来到了服务器端，可能会引起服务器端的处理错误。2，应答消息丢失，但是服务器认为建立成功了，所以一直发消息，又一直接受不到确认标志，将陷入死锁。**为什么三次握手不会导致上面的问题呢**，细化一下，client发送请求连接，服务器端收到了，常规思路就是回复一个确认消息，这就是两次握手，但是服务器端不知道这个确认消息客户端收到了没，所以会疑惑，因此在发送ACK的时候会同时发送一个SYN过去，等待客户端的确认，然后客户端再回送一个确认消息，而此时客户端处于半发送服务器半接受，如果服务器收到了确认，那么建立完成，如果丢失，应该有些机制比如重发或者按失效操作处理再重新发起一次请求。客户端是不会主动重传确认ACK的，除非服务机又发送了确认请求。
## 四次挥手  
释放连接的过程就比较复杂了，之所以比三次握手复杂一些，在于某一些操作可能未执行完毕或者为了安全释放连接起见。如下  
1.客户端发起释放连接请求，发送FIN=1，seq=c,然后处理处于FIN_AWAIT1状态  
2.服务器端收到请求，但是只是发送了ACK=1,seq=s，ack=c+1，处于close_await，因为此时服务器可能还在处理数据，必须等到数据处理完毕后再关闭连接。  
3.接收到服务器的确认后，此时客户端处于FIN_AWAIT2状态
4.待服务器处理完毕后，发送FIN=1，ACK=1，seq=ss，ack=c+1，然后处于LAST_ACK状态  
5.客户端接收到了服务器端的释放连接请求后，回送一个ACK=1，seq=c+1，ack=ss+1，然后处于TIME_WAIT状态。
**一些常见的问题**  
在四次挥手中为什么第五步不是直接关闭而是处理TIME_WAIT状态，并等待2MSL呢，这里主要是怕最后一次客户端发送回去的确认消息丢失，如果服务器端没有接收到这最后一次ACK的话，那么将会重新发起FIN=1操作，如果在该时间内收到了FIN，那么重置等待时间为2MSL，并重新发起回应服务器的确认消息。防止失效请求连接的干扰，因为2MSL后，该连接内所有的报文段都已失效。这样新的连接请求就不会被干扰了。
## 补充  
1.tcp报文段中的首部中有一些标志位，ACK（**大写**）=1才有效，ACK=0.无效。SYN代表同步的标志，SYN=1,ACK=0，代表这是一个请求，因此回复要用SYN=1,ACK=1。此外SYN只有在建立的时候为1，握手完成被重置为0.FIN是用来释放连接的，FIN=1表示传输完成要求释放连接。还有seq表示的是我将要发送的字节数据（这里的数据按字节编号）中第一个字节的序号，分段的话就是分段序列中第一个字节的序号。ack（**小写**）是用来确认收到数据的回复标志，通常是已接受报文段数据中最后一个字节+1.所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间
