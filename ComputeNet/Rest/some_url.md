# tcp三次握手4次挥手  
## 三次握手  
网上关于tcp三次的图已经很多了，这里只是记录同时检测自己对tcp三次握手的掌握程度。  
1.clietn发送一个SYN=1,seq=c，此时client处于SYN_SEND状态。  
2.server接收到client发送来的请求连接，也要回复并确认，发送ACK=1,SYN=1,seq=s,ack=c+1,服务器端处理SYN_RECIEVE状态。  
3.client接收到服务器端发送回来的信息，并回复确认信息，ACK=1,seq=c+1,ack=s+1,连接建立完成。  
**一些常见的问题**  
1.为什么tcp是三次握手不是两次握手。  
计网中说的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。其实我的理解就是会引起一些混乱而导致错误。比如A客户端像B服务器发起请求连接，但是由于网络拥堵导致请求连接未能到达服务器端，根据一些机制A可能会重新发送一个连接请求，而此次的连接服务器端接受到了，也发送了应答消息，此时又分为两种情况。1.应答消息接受成功，那么双方正常通讯，此时第一次失效的连接来到了服务器端，可能会引起服务器端的处理错误。2，应答消息丢失，但是服务器认为建立成功了，所以一直发消息，又一直接受不到确认标志，将陷入死锁。**为什么三次握手不会导致上面的问题呢**，细化一下，client发送请求连接，服务器端收到了，常规思路就是回复一个确认消息，这就是两次握手，但是服务器端不知道这个确认消息客户端收到了没，所以会疑惑，因此在发送ACK的时候会同时发送一个SYN过去，等待客户端的确认，然后客户端再回送一个确认消息，而此时客户端处于半发送服务器半接受，如果服务器收到了确认，那么建立完成，如果丢失，应该有些机制比如重发或者按失效操作处理再重新发起一次请求。客户端是不会主动重传确认ACK的，除非服务机又发送了确认请求。
## 四次挥手  
释放连接的过程就比较复杂了，之所以比三次握手复杂一些，在于某一些操作可能未执行完毕或者为了安全释放连接起见。如下  
1.客户端发起释放连接请求，发送FIN=1，seq=c,然后处理处于FIN_AWAIT1状态  
2.服务器端收到请求，但是只是发送了ACK=1,seq=s，ack=c+1，处于close_await，因为此时服务器可能还在处理数据，必须等到数据处理完毕后再关闭连接。  
3.接收到服务器的确认后，此时客户端处于FIN_AWAIT2状态
4.待服务器处理完毕后，发送FIN=1，ACK=1，seq=ss，ack=c+1，然后处于LAST_ACK状态  
5.客户端接收到了服务器端的释放连接请求后，回送一个ACK=1，seq=c+1，ack=ss+1，然后处于TIME_WAIT状态。
**一些常见的问题**  
在四次挥手中为什么第五步不是直接关闭而是处理TIME_WAIT状态，并等待2MSL呢？官方的答案有两个
- 优雅的关闭TCP连接，也就是尽量保证被动关闭的一端收到它自己发出去的FIN报文的ACK确认报文；
- 处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接 

首先一个ip数据报有一个MSL（报文最大生命时间，每一个协议都要制定这个时间，现在大多是30s），也有一个TTL（经过路由器的最大跳数），因此我们要假设任意一个报文段经过TTL的时间是小于等于MSL的。（参考unix网络编程2.7节）。
- 先看目的1，如果客户机不等待2msl，而是立即关闭，这个客户机的回复ACK报文可能在网络中失效（由于网络堵塞，超过MSL了），或者幸运的到了服务机，我们不能讲概率，得确保回复ACK报文能把服务机接收到，所以等待一个回复ACK报文（MSL）+服务机重发个FIN=1B报文=2MSL，确保了如果在这2MSL内没有重新接收到服务机超时重传的ACK报文段，那就说明服务端和客户端都已经优雅的关闭了，如果再次接收到，重置等待时间为2msl，重复上面的过程。  
- 再看目的2，如果一个没有上面的2MSL等待时间，假设服务机的ip和端口都没变，客户机在断开连接后，用同样的ip和端口建立了连接，这时由于上一次连接在关闭前可能发送了报文段数据，由于拥塞，在网络中缓慢移动，这里的缓慢可以理解为相对的，某一条最优路走不通了，需要走更长的路径，但是这个报文段没有失效，假设新连接正在发送某个数据段，这次上一次连接的数据段来了，因为id类信息都一样，服务机可能会错误的接收，导致实际我们传过去的报文变成了脏数据，所以为了解决这个问题，客户机可以等待一个MSL再发起连接建立请求足够了，因为一个MSL足以保证我发出去的数据已经失效了。
- 综上，一个2ms一个1ms，取两个最大值。2msl
## 补充  
1.tcp报文段中的首部中有一些标志位，ACK（**大写**）=1才有效，ACK=0.无效。SYN代表同步的标志，SYN=1,ACK=0，代表这是一个请求，因此回复要用SYN=1,ACK=1。此外SYN只有在建立的时候为1，握手完成被重置为0.FIN是用来释放连接的，FIN=1表示传输完成要求释放连接。还有seq表示的是我将要发送的字节数据（这里的数据按字节编号）中第一个字节的序号，分段的话就是分段序列中第一个字节的序号。ack（**小写**）是用来确认收到数据的回复标志，通常是已接受报文段数据中最后一个字节+1.所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间
