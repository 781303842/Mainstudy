# tcp三次握手4次挥手  
## 三次握手（http中可以通过keep-alive告诉服务机，我还要和你进行通讯，等会就不要再次三次握手了）  
网上关于tcp三次的图已经很多了，这里只是记录同时检测自己对tcp三次握手的掌握程度。  
1.clietn发送一个SYN=1,seq=c，此时client处于SYN_SEND状态。  
2.server接收到client发送来的请求连接，也要回复并确认，发送ACK=1,SYN=1,seq=s,ack=c+1,服务器端处理SYN_RECIEVE状态。  
3.client接收到服务器端发送回来的信息，并回复确认信息，ACK=1,seq=c+1,ack=s+1,连接建立完成。  
4.TCP 协议规定SYN报文虽然不携带数据， 但是也要消耗1个序列号， 所以前两次握手客户端和服务端都需要向对方回复 x+1 或 y+1
**一些常见的问题**  
为什么tcp是三次握手不是两次握手。  
- 防止旧的连接初始化造成混乱：
    + 情景1：谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接（知乎山尽）
    + 上面简单来说就是：2次握手，在新的连接请求报文建立连接并释放完成后，旧的连接请求到了，但是服务器只握手两次，依然为这个建立连接，但是客户机此时已经关了，不会发送消息，服务机一直等一直等，除非触发某个机制让服务机知道该客户机不可达了。3次握手，旧连接建立报文到了后，服务机箱客户机发送确认同步报文，客户机不会回复，次数多了，服务机知道不可达，就不会建立连接，分配资源了。
- 同步初试序号：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。
    + 如果没有同步初试序列号，双方接收信息的时候根本就不知道哪里是起点或者接受完整了没。
## 四次挥手  
释放连接的过程就比较复杂了，之所以比三次握手复杂一些，在于某一些操作可能未执行完毕或者为了安全释放连接起见。如下  
1.客户端发起释放连接请求，发送FIN=1，seq=c,然后处理处于FIN_AWAIT1状态  
2.服务器端收到请求，但是只是发送了ACK=1,seq=s，ack=c+1，处于close_await，因为此时服务器可能还在处理数据，必须等到数据处理完毕后再关闭连接。  
3.接收到服务器的确认后，此时客户端处于FIN_AWAIT2状态
4.待服务器处理完毕后，发送FIN=1，ACK=1，seq=ss，ack=c+1，然后处于LAST_ACK状态  
5.客户端接收到了服务器端的释放连接请求后，回送一个ACK=1，seq=c+1，ack=ss+1，然后处于TIME_WAIT状态。
**一些常见的问题**  
在四次挥手中为什么第五步不是直接关闭而是处理TIME_WAIT状态，并等待2MSL呢？官方的答案有两个
- 优雅的关闭TCP连接，也就是尽量保证被动关闭的一端收到它自己发出去的FIN报文的ACK确认报文；
- 处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接 

首先一个ip数据报有一个MSL（报文最大生命时间，每一个协议都要制定这个时间，现在大多是30s），也有一个TTL（经过路由器的最大跳数），因此我们要假设任意一个报文段经过TTL的时间是小于等于MSL的。（参考unix网络编程2.7节）。
- 先看目的1，如果客户机不等待2msl，而是立即关闭，这个客户机的回复ACK报文可能在网络中失效（由于网络堵塞，超过MSL了），或者幸运的到了服务机，我们不能讲概率，得确保回复ACK报文能把服务机接收到，所以等待一个回复ACK报文（MSL）+服务机重发个FIN=1B报文=2MSL，确保了如果在这2MSL内没有重新接收到服务机超时重传的ACK报文段，那就说明服务端和客户端都已经优雅的关闭了，如果再次接收到，重置等待时间为2msl，重复上面的过程。  
- 再看目的2，如果一个没有上面的2MSL等待时间，假设服务机的ip和端口都没变，客户机在断开连接后，用同样的ip和端口建立了连接，这时由于上一次连接在关闭前可能发送了报文段数据，由于拥塞，在网络中缓慢移动，这里的缓慢可以理解为相对的，某一条最优路走不通了，需要走更长的路径，但是这个报文段没有失效，假设新连接正在发送某个数据段，这次上一次连接的数据段来了，因为id类信息都一样，服务机可能会错误的接收，导致实际我们传过去的报文变成了脏数据，所以为了解决这个问题，客户机可以等待一个MSL再发起连接建立请求足够了，因为一个MSL足以保证我发出去的数据已经失效了。
- 综上，一个2ms一个1ms，取两个最大值。2msl
## 补充  
1.tcp报文段中的首部中有一些标志位，ACK（**大写**）=1才有效，ACK=0.无效。SYN代表同步的标志，SYN=1,ACK=0，代表这是一个请求，因此回复要用SYN=1,ACK=1。此外SYN只有在建立的时候为1，握手完成被重置为0.FIN是用来释放连接的，FIN=1表示传输完成要求释放连接。还有seq表示的是我将要发送的字节数据（这里的数据按字节编号）中第一个字节的序号，分段的话就是分段序列中第一个字节的序号。ack（**小写**）是用来确认收到数据的回复标志，通常是已接受报文段数据中最后一个字节+1.所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间
