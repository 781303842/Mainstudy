# final 关键字  
- final 变量，一旦值类型的变量声明为final，那么这个值类型的值不能改变；如果final一个数组，我们知道是引用，虽然数组对象本身不能改变，但是数组的值却可以改变
- final只能指向一个对象且不可变，在一个类中声明一个非静态final变量=随机值，每次生成类对象该final变量值都会改变，算不上真正的不会改变，可以使用 static final的形式，因为static的变量是在准备阶段都已经完成赋默认值，只有第一次执行，但是由于final必须给予初值，所以这是真正的不可变。通过多次生成对象，只会去重新赋值那些非静态成员变量，静态成员变量不会发生改变。
- final方法不能被重写，private方法隐私定义为final
- final类不能被继承。

# 内部类  
定义：定义在类中的类称为类部类  
- 内部类可以访问外部父类任意的变量和方法
- 内部类只能在外部父类中或者外部父类的非静态方法中实例化，如果不是的话需要使用`外部类.类部类,而且前提还是外部父类要有对象存在，不然不会生成内部类，内部类依附于外部父类`  
- 可以在外部父类中生成内部类对象去访问内部类的变量和方法，`不能直接访问内部类的变量`
- 内部类一个基本的用途就是，在一个内部类中去继承一个外部接口并实现该方法，然后在外部父类的非静态方法去实现内部类的向上转换为接口，因为返回类型为接口，这样就可以调用接口的f方法，隐藏了内部类的细节。
为什么是非静态方法？？  
- 可以通过this在内部类中访问不同的变量，比如在外部类和内部类中还有内部类中方法形参都相同时，可以通过`x++,this.x++,outclass.this.x++`区别。

# 局部内部类  
局部内部类，可以定义在任意位置，比如方法中等等。
- 该内部类是属于当前方法的，**作用域仅限于当前方法中**，因此内部类可以访问外部类中的任意变量和方法，但是只能访问方法的常量，用final去定义。
- 只能访问常量的原因，猜测是由于如果方法中传递了一个引用，并且和内部类继承了同意的父类或者父接口，有可能将内部类对象赋值给参数，发生对象逃逸，发生不可预知的错误，因为按理来说该内部类对象会随着
方法执行完毕，栈帧出栈而死亡。  

# 匿名内部类  
匿名内部类实例化后，会生成外部类$序号为名称的class文件。
```
class outcalss{
  outinterference doit(){
    return new outinterference(){
      //操作
    };
  }
}
```  

# 静态内部类  
在内部类前面加上`static`关键字，就形成了静态内部类
- 在静态内部类中只能声明static成员，且不能使用外部父类的非静态成员。
- 静态内部类创建对象不需要外部父类的对象存在
- 不能从静态内部类的对象中访问外部父类的非静态对象  

# 内部类的继承  
在一个类中继承一个内部类的时候，必须声明一个有参的构造函数，且该构造函数的参数类型是内部类的外部父类，并且在构造函数中还要调用内部类外部父类的spuer方法，这里我猜测是因为非静态内部类依附于外部类，所以要先调用外部父类的构造函数。如果继承的是静态内部类，那没必要了，因为静态内部类不需要依赖外部父类。
```
class c extends b,c{
    public c(b b1){
      super.b1();
    }
}

class b{
    class c{}
}
```  

# 异常  
通过try catch finally来处理，finall是最后都会执行的步骤，可以通过继承exception类自定义异常。
![异常](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png)
