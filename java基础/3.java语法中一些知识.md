# equals和==
如果在没有重写equals方法的时候，equals和==比较的都是对象的堆地址。但是实际上我们经常使用的一些类，比如String，它已经重写了equals方法，所以比较的是内容。当然，如果是基本是值类型，比较的是内容  
**引申1**  
为什么重写equals方法一定要重写hashcode，假定有这样的一个场景，对于某个对象只要内容相等，我们就假定这两个对象在逻辑上相等，但是equals比较的是内存地址，所以我们需要重写equals方法，但是为什么要重写
hashcode方法呢，这是因为在map接口的实现类中，key是以对象的hashcode计算得到一个散列值，但是在重写了equals方法前提下，不重写hashcode会导致两个在我们假定逻辑上相等的对象，散列到不同的地方去了，我们
实际上要的效果是A对象的内存地址和B对象内存地址hash出来的key值都相等，所以后面如果通过A对象get会取出来2个对象，这样才符合我们的要求。如果不重写hashcode，我们认为相等的，但是hash出来的key却不同。  
**引申2**  
```
String a="abc";//可以产生对象，放在元数据区的常量池中，如果常量池中不存在abc对象，则创建一个，如果存在，则直接返回引用。另外凡是通过new的都是产生的新对象，内存地址肯定不一样。
还有一个integer  
1. int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。

2. Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128<= x<=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，
不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。

3. new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 
大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。
```
