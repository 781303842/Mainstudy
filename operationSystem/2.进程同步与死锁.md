# 进程同步  
1.为什么要进行进程同步：从进程的角度来看，如果不对进程处理过程做同步，在多个进程处理协调处理一个任务时候可能出问题，比如计算a+b/c，A进程负责加法，B进程负责减法，如果A进程先执行结果就会问有问题。  
2.临界资源： 一次只允许一个进程访问的资源。临界区：一次只允许一个进程访问的代码段。  
3.进程同步的方式。进程互斥满足4个条件：空着让进，忙着等待，有限等待，让权等待。软件的实现：
- 单标志法：通过一个标志位`flag=1`让两个线程交替执行，当A进程执行的时候，若`flag==1，则进入临界区执行并修改flag=2`；B进程执行的时候，若`flag==2，则进入临界区执行，
执行完后修改flag=1。`这么做会有什么问题呢？**如果A线程执行一次过后，再也不执行了，那么B进程执行完一次后再也不能执行了，因为flag一直=1了，违背了空闲让进**
- 双标志先检查法：通过一个标志数据flag[2]来表示两个进程是否正在执行；在进程A中通过死循环检查flag[B],如果flag[B]为true，也就是说B进程在执行，那么A进程就等待；如果死循环检查的时候B进程没有执行，则进入
临界区，并修改自己的flag[A]=true。B进程执行的过程同理，但是这么做也有问题，就是当A和B进程在死循环检查通过后，还没来得及将自己的flag修改为true，就都通过了，所以违背了忙着等待。也有问题。  
- 双标志后检查法：问题在于如果同时将自己的flag设为true，那么检查的时候都会认为对方在执行，进行死循环。  
- 皮特逊算法：解决了上面三个问题。  
![双标志先检查](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5.png)
![双标志后检查](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5.png)
![皮特逊算法](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%9A%AE%E7%89%B9%E8%8D%AA%E7%AE%97%E6%B3%95.png)  

硬件一般通过关闭中断，因为只有中断cpu的执行会引起进程切换。  

4.信号量  
其实就是通过两个不可中断的原子操作，如果要申请某种资源进进行P操作，如果要释放某种资源就进行V操作。
