# 进程同步  
1.为什么要进行进程同步：从进程的角度来看，如果不对进程处理过程做同步，在多个进程处理协调处理一个任务时候可能出问题，比如计算a+b/c，A进程负责加法，B进程负责减法，如果A进程先执行结果就会问有问题。  
2.临界资源： 一次只允许一个进程访问的资源。临界区：一次只允许一个进程访问的代码段。  
3.进程同步的方式。进程互斥满足4个条件：空着让进，忙着等待，有限等待，让权等待。软件的实现：
- 单标志法：通过一个标志位`flag=1`让两个线程交替执行，当A进程执行的时候，若`flag==1，则进入临界区执行并修改flag=2`；B进程执行的时候，若`flag==2，则进入临界区执行，
执行完后修改flag=1。`这么做会有什么问题呢？**如果A线程执行一次过后，再也不执行了，那么B进程执行完一次后再也不能执行了，因为flag一直=1了，违背了空闲让进**
- 双标志先检查法：通过一个标志数据flag[2]来表示两个进程是否正在执行；在进程A中通过死循环检查flag[B],如果flag[B]为true，也就是说B进程在执行，那么A进程就等待；如果死循环检查的时候B进程没有执行，则进入
临界区，并修改自己的flag[A]=true。B进程执行的过程同理，但是这么做也有问题，就是当A和B进程在死循环检查通过后，还没来得及将自己的flag修改为true，就都通过了，所以违背了忙着等待。也有问题。  
- 双标志后检查法：问题在于如果同时将自己的flag设为true，那么检查的时候都会认为对方在执行，进行死循环。  
- 皮特逊算法：解决了上面三个问题。  
![双标志先检查](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5.png)
![双标志后检查](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5.png)
![皮特逊算法](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%9A%AE%E7%89%B9%E8%8D%AA%E7%AE%97%E6%B3%95.png)  

硬件一般通过关闭中断，因为只有中断cpu的执行会引起进程切换。  

4.信号量  
其实就是通过两个不可中断的原子操作，如果要申请某种资源进进行P操作，如果要释放某种资源就进行V操作。  

# 死锁  
1.定义：若干进程由于互相持有对方需要的且不能被剥夺的资源而形成一种环路，如果没有外力作用，这么环将一直存在，称为死锁。
2.产生的原因：系统不可剥夺资源的竞争，或者说是进程不合理的推进顺序导致的。
3.进程死锁的必须满足的4个条件：
- 互斥条件：对应不可剥夺资源一段时间内只能有一个进程使用。其它进程要用只能等待。
- 不剥夺条件：进程在执行过程中获得的资源在进程结束之前，都不能被其它进程剥夺，只能由自己释放。 
- 请求和保持条件：在对新资源进行请求的时候，已经持有的资源不会进行释放。
- 循环等待资源：就是若干进程互相等待已经被持有的资源而形成一条环路。

上述条件只要破坏一个就不会产生死锁。


4.死锁的处理策略  
4.1 死锁预防（破坏4个死锁条件任意一个或多个）
- 破坏互斥条件：虽然简单粗暴，但是不可行，比如打印机这种资源必须互斥处理。
- 破坏不可剥夺条件：虽然可行，但是释放已经占有的资源，可能导致之前的工作白做了，又要重新申请，降低系统的处理能力。
- 破坏请求和保持条件： 一次性把某个进程的资源都分配，过于粗暴不建议使用，可能导致其他进程一直处于饥饿状态。
- 破坏循环等待：对资源进行编号，同类资源一次申请完，之后的过程中只能申请大于前面资源编号的资源了。  
4.2 死锁避免  
允许系统动态进行资源分配，不过分配前需要计算此次分配是否会导致进程不安全也就是说只要能找到一个使所有进程都能获取需要的资源的顺序就是安全的。著名的算法有银行家算法，简单描述一下过程，
- `矩阵A表示若干进程对若干资源的需求量`，比如[[1,2,3][2,2,1]]行看出进程，列看成不同资源的资源数量
- `矩阵B表示每一个进程以及分配的若干资源数量`，比如[[1,1,1][2,2,0]]
- `两个矩阵一减，得到一个need矩阵`，比如[[0,1,2][0,0,1]]表示每个进程对每种资源还需要的数量
- `将need矩阵和available矩阵对比，available矩阵表示每种资源当前可提供的数量`，如果need中某一行都小于available矩阵的话，则need行对应的进程可以执行，并释放资源，将对应的资源加到available上
再迭代处理，最后如果每一个进程都能执行，说明当前分配资源是安全的。  

**注意 银行家算法只能说明有一个序列是安全的，不能保证线程不会发生死锁。**  

5死锁检测和解除  
5.1 死锁的检测  
资源分配图方法，通过消去资源分配图中的边来检测是否存在死锁，简单来说就是在图中找到一个进程，当它申请的资源资源小于空闲的资源，如果当前进程可以满足，就消去所有和该进程有关的边，再迭代，最后如果所有边都消去了说嘛不存在死锁。
![资源分配图](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png)
5.2 死锁的解除
- 释放资源
- 撤销进程
- 进程回退  

6.死锁处理策略的一个比较  
![比较](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83.png)
