# 内存管理定义  
1.定义：对内存进行划分和回收的处理。为什么要有内存管理，有些情况下无法一次性将程序代码所有都加载到内存中去，需要按照某种特定的数据结构在需要的时候才将程序从辅助加载到主存。  
2.地址转换：多道环境下，每个程序的逻辑起始空间都是0，需要将逻辑地址变为物理地址，需要地址重定位寄存器，存放的是偏移量，逻辑地址+偏移量=物理地址。  
3.内存保护：多道环境下，要保证当前程序不能被其它程序非法干扰，因此需要对当前程序设置一个内存上下限，下限就是地址寄存器中的偏移量，上限用一个界地址寄存器来保存，在地址转换的时候只有合法的地址才会被zhuan
为物理地址。

# 连续分配管理方式  
 - 单一连续分配：这种分配方式下，低地址分为系统区，剩下的就是用户区，一次只能装入一道程序，且会产生内碎片。
 - 固定分区分配：有两种。1，每一种分区都是相等的。2 分区大小不等。
 - 使用呢：通过一张记录表，表明每个分区的起始地址，分区大小，状态（是否分配等信息）来完成分配。  
 
 缺点就是如果程序比分区小，那么会产生内碎片；当然也有可能，任何一个分区都装不下，那么只有使用覆盖技术了。  
 
 # 动态分配方式  
 有点类似单一连续分配，但是要高级一些；来一个程序就在内存中分配一个连续的空间给他，随着程序的分配和消亡，会产生内碎片，可以通过紧凑技术解决这个问题，说白了就是操作系统对程序不断往前移动，如果程序前面
 有空闲区。分配的方式有如下几种：
 - 首次适应：**空闲分区空间地址递增的次序链接**，就是说第一次遇到能放下当前程序的内存块就将程序装入（通常效率最好，但是在低地址空间会形成很多**小的**外部碎片）
 - 最佳适应：**按容量大小递增形成空闲分区链**，找到第一个满足要求的内存块（通常效率不好，产生最多的外碎片）
 - 最坏适应：**按容量大小递减形成空闲分区链**，找到第一个满足要求的内存块（将最大的连续内存快速用光，后面导致需要大空闲内存的时候没有可用得了）
 - 邻近适应：**在首次适应的基础上，增加了从上一次的位置往下找**（通过在末尾地址空间形成很多外部碎片，效果通常也很差）  
 
 # 非连续分配  
 
## 分页

页：将内存和进程分为大小固定的页，外存也可以分页，这样的好处在于，虽然很类似动态分区，但是实际上这里将进程也做了分页的处理，所以只有在进程的最后一个页面会产生内碎边，大大提升了内存的使用率。
分页又分为两种：一种是基本分页，一种是请求分页，这两种分页的区别就是看是否一次将所有页面装入内存。  
逻辑地址结构：比如32位的逻辑地址，低20位可能是偏移量，高11位是页号。这里参考下面的内容进行理解。  
页表：每一个进程都有一个页面，只有在进程开始运行的时候才会将页表起始地址和页表项长度（这里指的是当前页表有多少项）装入内存。作用是将逻辑地址中的高位对应的页号映射到实际的内存物理地址。如下图
![地址转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)  

- 从逻辑地址高位中计算出页号，在对应的页表寄存器中（每个进程至少有一个页表，单级页表是放在内存中）找到自己的页表，然后对比页号是否比页表项大，如果大，中断退出
- 小于的话，继续执行，在页表中找到当前页号对应的物理块（页）号，通过当前物理页号\*页大小+逻辑地址中的偏移量得到当前指令请求的地址。  

这样的话，其实也有一点点问题，就是速度会慢了，就是访问了两次内存，一次访问页表，一次访问实际内存。那能不能做一些优化呢？在计算机中有一个局部性原理，可以从数据的角度来说就是刚刚访问的再次访问的
可能性很大，于是引进了快表（一个高速缓存器），如图：  
![快表地址转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E6%9E%84.png)

- 取决于如何执行，一般而言在快表中直接存放的是当前进程的逻辑页号和实际物理页号的映射。
- 因此来了一个逻辑地址，首先取得逻辑页号去快表中找，如果找的得直接返回，再计算出物理地址（有数据说快表的命中率在90%）
- 快表不命中时，再通过普通的地址转换流程去找。（也就是加了快表的地址转换失败率一般在10%）  

至此对查找过程的优化已经差不多了，但是另一个问题，如果页表也很大呢，就是有很多页表项，也会占据相当可观的内存资源，于是引进了多级页表，比如在32位地址中，31-21是一级页表地址，20-11是二级页表，10-0是地址偏移量。**规定只能有一个一级页表**。查找过程可以通过一级页表地址找到二级页表，剩余过程可以同上，这样如果有必要，我可以将大量的二级页表在需要执行的时候才从外存加载到主存。
## 分段
分页是站在计算机的角度上，而分段是站在程序的角度，将程序分为若干大小不同段，段内连续，段间不一定连续。逻辑地址分为`段号+偏移量`，段表的结构为`段号+段长+基址`，这里段长呢是当前逻辑地址中的段号只能在当前段号所对的连续空间上操作，不能越界，而页表中是物理页号，这里咋就成了基址呢，以为分段后，段的大小不唯一了，不能固定的通过页号\*页长得到实际物理起始地址了，因此这里一开始放的就是起始地址。  
![分段转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)  
注意分段共享数据的存储控制保护，比页表多了这一项。  

## 段页式  
分页的方式能提高利用效率，分段能更好的反应逻辑结构和利用段的共享，因此结合起来，形成了段页式分配。具体操作就是将程序分为若干段，比如程序段，数据段等等，每一个段都有一个段号，然后对每一个段再按
分页进行管理，也就是说段表中的结构格式变为了`段号+段长+页表起始地址，作业的结构变为段号+页号+偏移量` ，每一个段对应一个页表，也就是段页式中只能有一个段表，但是有多个页表。 
![段页管理](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%AE%B5%E9%A1%B5%E7%AE%A1%E7%90%86.png)  
![段页查找](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%AE%B5%E9%A1%B5%E6%9F%A5%E6%89%BE.png)  

# 传统内存管理总结  
从上面可以看出具有两个特征
- 作业要一次性全部装入内存，如果一次装不下，那就没办法运行了（一次性）  
- 驻留性，在作业变为进程执行期间，所有的部分都全部装在内存中，直到作业运行结束。
- 暂时不用的数据也装在了，一次性装入导致太大而不能执行，浪费了内存资源。  

# 局部性原理  
- 时间局部性：一条指令被访问过后，再次访问的几率很大，因为程序中有许多循环操作。
- 空间局部性：一个地址被访问过后，其周边的地址被访问的可能性增大，一般来说是因为指令是顺序存放和顺序执行的。  

# 虚拟内存  
正是由于局部性原理，所以在程序执行时不必将所有"部分"都装入内存，在装入部分后就启动程序，在执行的时候如果需要访问不在内存中的部分再把该部分从外存加载到内存，而且还可以将暂时用不到的移到外存中，
之所以将虚拟内存，因为对用户而言就好像无论多大的作业都能运行，但是这种只是一种逻辑上的扩充，实际内存并没有变大，所以叫虚拟内存。三个特性： 
- 多次性：无需一次将所有作业的部分都加载到内存中，可以多次加载
- 对换性：无需将某部分一直常驻内存，而是允许在需要和暂时不用的时候，进行调入和换出操作
- 虚拟性：只是从逻辑上扩充了内存，是从用户的角度出发的。  

## 虚拟内存技术的实现  
其实就是在上面讲的基础上加上请求两个字，之所以用请求就是需要的时候才请求加载进入到内存。除了常规的地址转换，页表段表等数据结构和内存外存的支持，还需要中断的支持，因为如果执行的时候发送需要的部分
不在内存中，需要中断，然后从外存中加载到内存。

## 请求分页存储管理  
1.在请求分页中，页表项的结构发生了变化，因为我们要去监控块是否在内存已经这个块修改过没，以及给程序提供换出内存时候的一个参考指标，就是访问字段。`页号+物理块号+状态+访问字段+修改位`
- 页号：和我们前面说的页号没有区别
- 物理块号：上同
- 状态：供程序识别，当前物理块对应的数据或者指令是否已经加载到内存中
- 访问字段：表示访问的频率等待，供将暂时用不到的页置换出去做一个参考
- 修改位：当前的数据或者指令是否修改过  

2.缺页中断结构，如果运行时发现需要的页不在内存中，就执行缺页中断，去外存将需要的物理块加载到内存，阻塞进程（调入页完成后唤醒），这个时候如果内存充足直接加入，内存没有空闲块了，就通过置换算法将
某些可能暂时用不到的页置换出去（如果被淘汰的页被修改过，该页还需要写回瓦外存）。一般的中断是在一条指令执行完过后检查，而缺页中断是发生在指令执行期间，并且可能发生多次中断，属于内中断。  

3.地址转换机构  
![请求分页地址中断](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)  

4.页面置换算法  
4.1 最佳置换算法（opt，无法实现，只是作为其他置换算法工作效率的一个对比）  
定义：在一个页访问顺序集合中，如果当前内存块满了，需要将**以后都不使用或者长时间不使用的块淘汰**。比如空闲区有4块，页访问3,4,5,1,6，4,3,5，可以看出1是后面都不会使用的所以淘汰。注意
（最长时间不使用和以后被访问次数最小是两个概念）  
![置换图](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E7%BD%AE%E6%8D%A2%E5%9B%BE.png)  
4.2 先进先出算法（效果较差，就是先来的先出去，而且先进先出还会导致beledy，就是随着空闲区的增大，缺页次数反而增多，lru和opt都不会）  
4.3最近最久未使用（LRU）  
简单描述一下过程，就是在空闲块还有的时候直接如果没有命中则直接添加，并处于**最新的位置**，之前的块顺序往后挪，如果命中不添加，但是要把该块提前到最新的位置，因为最旧的位置，如果空闲区满了且没命中就要被淘汰。  
![lru](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/LRU.png)  

4.4 clock算法（NRU，最近未使用）  
主要思想就是利用一个循环缓存区，将调入内存的每一页都用一个位来表示是否使用过，用一个**指针来指向循环缓存区中当前的位置**，如果在要发生置换的时候，这个指针依次往下移动，移动的过程发送使用位为1
的就将使用位标志位0，如果遇到0的就将该页替换出去，如果循环了一圈都没发现为0的，则将起点处的页置换出来，因为这一圈下来所有的使用位都为0了。  

4.5改进型clock算法  
在clock算法的基础上又增加了一个是否修改位，有4种组合。
- w未被使用位，未被修改位(u=0,m=0)
- w被使用位，未被修改位(u=1,m=0)
- w未被使用位，被修改位(u=0,m=1)这里注意一下是最近未被访问，不是一直没被访问，所以这个修改来自于之前的访问
- w被使用位，被修改位(u=1,m=1)  

置换流程如下：
- 从中找到第一个`u=0,m=0`的置换出去，如果没找到，到第二步
- 找到第一个u=0,m=1。这个过程中不断将u=1修改为u=0,如果找到了就置换出去。
- 如果一圈下来都没找到，那么将从上面开始执行，一定能找到一个置换出去。  

对于clock算法要这么理解，基于局部性原理，其实都希望最近被访问的留在内存中，而那些太长时间没被访问的都置换出去。

5.分页大小策略  
回到前面的问题，说的是不必一次装入，只是在一开始装入部分，那么这个一部分该如何考虑呢，可以从三个方面：
- 分配的小，那么内存可以放下更多进程，可高并发性
- 但是如果分配的太小，可能会导致缺页率陡增  
- 适中适中适中，我也不知道分配多大了，cry~~~~~~  

6.抖动  
就是刚刚置换出去的页又被加载进来，频繁以上的操作就叫抖动。主要原因就是进程频繁访问的页面数目高于分配的空闲区数量。  

7.虚拟内存的大小
- 虚拟内存<=内存+外存之和。
- 虚拟内存<=计算机地址所能容纳的最大位数，比如32位的地址，那么最大只能访问到2^32=4g，超过4g的地址没法访问。

## 请求分段存储管理
大致操作和上面一样不过是加入了段表。下同
## 请求段页式管理
