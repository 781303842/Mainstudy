# 内存管理定义  
1.定义：对内存进行划分和回收的处理。为什么要有内存管理，有些情况下无法一次性将程序代码所有都加载到内存中去，需要按照某种特定的数据结构在需要的时候才将程序从辅助加载到主存。  
2.地址转换：多道环境下，每个程序的逻辑起始空间都是0，需要将逻辑地址变为物理地址，需要地址重定位寄存器，存放的是偏移量，逻辑地址+偏移量=物理地址。  
3.内存保护：多道环境下，要保证当前程序不能被其它程序非法干扰，因此需要对当前程序设置一个内存上下限，下限就是地址寄存器中的偏移量，上限用一个界地址寄存器来保存，在地址转换的时候只有合法的地址才会被zhuan
为物理地址。

# 连续分配管理方式  
 - 单一连续分配：这种分配方式下，低地址分为系统区，剩下的就是用户区，一次只能装入一道程序，且会产生内碎片。
 - 固定分区分配：有两种。1，每一种分区都是相等的。2 分区大小不等。
 - 使用呢：通过一张记录表，表明每个分区的起始地址，分区大小，状态（是否分配等信息）来完成分配。  
 
 缺点就是如果程序比分区小，那么会产生内碎片；当然也有可能，任何一个分区都装不下，那么只有使用覆盖技术了。  
 
 # 动态分配方式  
 有点类似单一连续分配，但是要高级一些；来一个程序就在内存中分配一个连续的空间给他，随着程序的分配和消亡，会产生内碎片，可以通过紧凑技术解决这个问题，说白了就是操作系统对程序不断往前移动，如果程序前面
 有空闲区。分配的方式有如下几种：
 - 首次适应：**空闲分区空间地址递增的次序链接**，就是说第一次遇到能放下当前程序的内存块就将程序装入（通常效率最好，但是在低地址空间会形成很多**小的**外部碎片）
 - 最佳适应：**按容量大小递增形成空闲分区链**，找到第一个满足要求的内存块（通常效率不好，产生最多的外碎片）
 - 最坏适应：**按容量大小递减形成空闲分区链**，找到第一个满足要求的内存块（将最大的连续内存快速用光，后面导致需要大空闲内存的时候没有可用得了）
 - 邻近适应：**在首次适应的基础上，增加了从上一次的位置往下找**（通过在末尾地址空间形成很多外部碎片，效果通常也很差）
