# 内存管理定义  
1.定义：对内存进行划分和回收的处理。为什么要有内存管理，有些情况下无法一次性将程序代码所有都加载到内存中去，需要按照某种特定的数据结构在需要的时候才将程序从辅助加载到主存。  
2.地址转换：多道环境下，每个程序的逻辑起始空间都是0，需要将逻辑地址变为物理地址，需要地址重定位寄存器，存放的是偏移量，逻辑地址+偏移量=物理地址。  
3.内存保护：多道环境下，要保证当前程序不能被其它程序非法干扰，因此需要对当前程序设置一个内存上下限，下限就是地址寄存器中的偏移量，上限用一个界地址寄存器来保存，在地址转换的时候只有合法的地址才会被zhuan
为物理地址。

# 连续分配管理方式  
 - 单一连续分配：这种分配方式下，低地址分为系统区，剩下的就是用户区，一次只能装入一道程序，且会产生内碎片。
 - 固定分区分配：有两种。1，每一种分区都是相等的。2 分区大小不等。
 - 使用呢：通过一张记录表，表明每个分区的起始地址，分区大小，状态（是否分配等信息）来完成分配。  
 
 缺点就是如果程序比分区小，那么会产生内碎片；当然也有可能，任何一个分区都装不下，那么只有使用覆盖技术了。  
 
 # 动态分配方式  
 有点类似单一连续分配，但是要高级一些；来一个程序就在内存中分配一个连续的空间给他，随着程序的分配和消亡，会产生内碎片，可以通过紧凑技术解决这个问题，说白了就是操作系统对程序不断往前移动，如果程序前面
 有空闲区。分配的方式有如下几种：
 - 首次适应：**空闲分区空间地址递增的次序链接**，就是说第一次遇到能放下当前程序的内存块就将程序装入（通常效率最好，但是在低地址空间会形成很多**小的**外部碎片）
 - 最佳适应：**按容量大小递增形成空闲分区链**，找到第一个满足要求的内存块（通常效率不好，产生最多的外碎片）
 - 最坏适应：**按容量大小递减形成空闲分区链**，找到第一个满足要求的内存块（将最大的连续内存快速用光，后面导致需要大空闲内存的时候没有可用得了）
 - 邻近适应：**在首次适应的基础上，增加了从上一次的位置往下找**（通过在末尾地址空间形成很多外部碎片，效果通常也很差）  
 
 # 非连续分配  
 
## 分页

页：将内存和进程分为大小固定的页，外存也可以分页，这样的好处在于，虽然很类似动态分区，但是实际上这里将进程也做了分页的处理，所以只有在进程的最后一个页面会产生内碎边，大大提升了内存的使用率。
分页又分为两种：一种是基本分页，一种是请求分页，这两种分页的区别就是看是否一次将所有页面装入内存。  
逻辑地址结构：比如32位的逻辑地址，低20位可能是偏移量，高11位是页号。这里参考下面的内容进行理解。  
页表：每一个进程都有一个页面，只有在进程开始运行的时候才会将页表起始地址和页表项长度（这里指的是当前页表有多少项）装入内存。作用是将逻辑地址中的高位对应的页号映射到实际的内存物理地址。如下图
![地址转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)  

- 从逻辑地址高位中计算出页号，在对应的页表寄存器中（每个进程至少有一个页表，单级页表是放在内存中）找到自己的页表，然后对比页号是否比页表项大，如果大，中断退出
- 小于的话，继续执行，在页表中找到当前页号对应的物理块（页）号，通过当前物理页号\*页大小+逻辑地址中的偏移量得到当前指令请求的地址。  

这样的话，其实也有一点点问题，就是速度会慢了，就是访问了两次内存，一次访问页表，一次访问实际内存。那能不能做一些优化呢？在计算机中有一个局部性原理，可以从数据的角度来说就是刚刚访问的再次访问的
可能性很大，于是引进了快表（一个高速缓存器），如图：  
![快表地址转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E6%9E%84.png)

- 取决于如何执行，一般而言在快表中直接存放的是当前进程的逻辑页号和实际物理页号的映射。
- 因此来了一个逻辑地址，首先取得逻辑页号去快表中找，如果找的得直接返回，再计算出物理地址（有数据说快表的命中率在90%）
- 快表不命中时，再通过普通的地址转换流程去找。（也就是加了快表的地址转换失败率一般在10%）  

至此对查找过程的优化已经差不多了，但是另一个问题，如果页表也很大呢，就是有很多页表项，也会占据相当可观的内存资源，于是引进了多级页表，比如在32位地址中，31-21是一级页表地址，20-11是二级页表，10-0是地址偏移量。**规定只能有一个一级页表**。查找过程可以通过一级页表地址找到二级页表，剩余过程可以同上，这样如果有必要，我可以将大量的二级页表在需要执行的时候才从外存加载到主存。
## 分段
分页是站在计算机的角度上，而分段是站在程序的角度，将程序分为若干大小不同段，段内连续，段间不一定连续。逻辑地址分为`段号+偏移量`，段表的结构为`段号+段长+基址`，这里段长呢是当前逻辑地址中的段号只能在当前段号所对的连续空间上操作，不能越界，而页表中是物理页号，这里咋就成了基址呢，以为分段后，段的大小不唯一了，不能固定的通过页号\*页长得到实际物理起始地址了，因此这里一开始放的就是起始地址。  
![分段转换](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)  
注意分段共享数据的存储控制保护，比页表多了这一项。  

## 段页式  
分页的方式能提高利用效率，分段能更好的反应逻辑结构和利用段的共享，因此结合起来，形成了段页式分配。具体操作就是将程序分为若干段，比如程序段，数据段等等，每一个段都有一个段号，然后对每一个段再按
分页进行管理，也就是说段表中的结构格式变为了`段号+段长+页表起始地址，作业的结构变为段号+页号+偏移量` ，每一个段对应一个页表，也就是段页式中只能有一个段表，但是有多个页表。 
![段页管理](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%AE%B5%E9%A1%B5%E7%AE%A1%E7%90%86.png)  
![段页查找](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E6%AE%B5%E9%A1%B5%E6%9F%A5%E6%89%BE.png)
