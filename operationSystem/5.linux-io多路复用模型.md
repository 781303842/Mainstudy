# select  
```
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
//该函数成功返回时，仅包含三个事件中某一个事件类型的就绪文件描述符集合。
int select (int n,//等于集合中文件描述符最大的那个加1
            fd_set *readfds,//来监控文件描述符集合中是否有可读数据
            fd_set *writefds,writedfs用来监控文件描述符集合中是否有可写数据
            fd_set *exceptfds,exceptfds监控文件描述符集合中，是否有异常等等。
            struct timeval *timeout);//如果timeout不是null，就算此时没有文件描述符就绪，也会在tv_sec秒和tv_userc微秒后返回。

  FD_CLR(int fd, fd_set *set);//向指定集合中删除一个文件描述符
  FD_ISSET(int fd, fd_set *set);//用来测试一个文件描述符是否在一个集合中，在返回一个非0值，不然返回0
  FD_SET(int fd, fd_set *set);//向指定集合中添加一个文件描述符
  FD_ZERO(fd_set *set);  //用来移除指定集合中所有文件描述符
  
#include <sys/time.h>
struct timeval {
long tv_sec; /* seconds 秒*/
long tv_usec; /* microseconds 微秒*/
};
```
linux中遵循一切皆文件的理念，文件是用文件描述符来描述的，每一个文件都有一个唯一的inode编号。io多路复用允许在多个文件描述符上同时阻塞，并在其中某个可读或者可写时接收通知。  
- select函数中第一个参数n，就是当前监控的文件描述符中值最大的那个1。  
- 通过三个指针readfds，writefds,exceptfds来监控三种不同的事件。  
# poll  
```
#include <sys/poll.h>
//与select不同通过三个指针监控不同的集合，poll通过nfds个pollfd文件构成的数组。fds指向这个数组。
//成功时返回fds数组中事件就绪的文件描述符的个数
//返回0表示超时时间到了。
//返回-1表示调用失败，对应的错误码会被设置。
int poll (struct pollfd *fds, unsigned int nfds,
            int timeout);//任何io就绪前需要等待的时间长度，单位是毫秒。负值代表永远等待，0代表立马返回
            
            
#include <sys/poll.h>
//每个pollfd监控一个文件描述符，可以有多个结构来监控多个文件描述符
//监控一个文件时，通过设置events，然后返回时在revents中去检查。
struct pollfd {
            int fd; /* file descriptor 需要关心的文件描述符*/
            short events; /* requested events to watch 在该文件描述符上要去监控的一组事件的位掩码，我觉得人话估计就是通过某几个的组合来表示不同的事件，下同*/
            short revents; /* returned events witnessed 在该文件描述符上实际发生的一组事件位掩码。*/
};
```
poll函数实现原理
（1）将需要关心的文件描述符放进fds数组中  
（2）调用poll函数  
（3）函数成功返回后根据返回值遍历fds数组，将关心的事件与结构体中的revents相与判断事件是否就绪。  
（4）事件就绪执行相关操作。
# epoll
