# 内核态（系统空间）和用户态（用户空间）  
1.用户空间是用户进程所在的内存区域，系统空间是操作系统所在的内存区域。大内核是将所欲的功能都集中到内核中，而微内核是将必要的集中到内核，比如io，网络等等。  
2.文件描述符，在linux中，所有设备都当做文件处理，文件描述符用来描述每个对象，当打开一个文件或者设备时，内核给进程返回一个文件描述符。（inode后面详解）
3.缓存io，会先将io数据缓存在内核的缓存区，然后才将数据从内核拷贝到应用程序的地址下面。  
4.select，poll，epoll  
- select，调用select后，会阻塞在这里，直到内核监控的socket中有连接就绪（读就绪，写就绪，异常）等才会返回，然后遍历当前seelct对应的所有的连接，找到就绪的socket，缺点就是最大只能监听1204，虽然可以修改宏文件，但是效果不好
- poll 也是要轮训所有socket，但是没有了最大连接数的要求，当连接数一多，同时就绪的socket很少，所以效率降低
- epoll

# 同步异步 阻塞非阻塞(在Unix io系统调用而言)  
io操作有两个阶段，第一是**数据准备阶段，第二是从内核拷贝到用户态下的缓存区**。  
阻塞和非阻塞的区别：在于数据准备阶段是非会阻塞io请求线程，如果阻塞了就是阻塞io，如果没有阻塞在这个阶段通过轮训持续询问的方式叫非阻塞io。  
同步和异步的区别：上面的阻塞io和非阻塞io都是同步io，因为它们在第二个阶段都会阻塞线程。 

1.在io系统调用中（io一般需要去读硬盘或者其它设备的数据，需要交给核心态去完成也就是系统调用，进程的切换时上下文保存到对应的进程控制块中pcb），  
- 异步io和非阻塞io的区别在于，异步io会在将来的某个时间点返回完整的数据，而非阻塞io会立即返回可用数据，可能是空或者不完整都有可能。异步在两个阶段都不会阻塞。  
- io多路复用也是同步io，阻塞不是recvfrom，而是阻塞于select或者epoll等，当任何一个socket数据准备完毕后，返回通知通过recvfrom将对应数据拷贝到用户态下的缓存区。  

![阻塞io](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%98%BB%E5%A1%9Eio.JPG)
![非阻塞io](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%9D%9E%E9%98%BB%E5%A1%9Eio.JPG)
![io复用模型](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/io%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.JPG)
![异步io](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E5%BC%82%E6%AD%A5io.JPG)
![额外信息](https://github.com/781303842/Mainstudy/blob/master/ALLIMG/%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF.JPG)


# 同步异步 阻塞非阻塞（从进程/线程的通讯角度而言）  
1.从进程间通讯来说，在针对发送方和接收方来说，同步和阻塞，异步和非阻塞是同义词。  

同步阻塞方式：
    发送方发送请求之后一直等待响应。
    接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。

同步非阻塞方式：
	发送方发送请求之后，一直等待响应。
	接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。
	但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。
	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）

异步阻塞方式：
	发送方向接收方请求后，不等待响应，可以继续其他工作。
	接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）

异步非阻塞方式：
	发送方向接收方请求后，不等待响应，可以继续其他工作。
	接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。
	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）
